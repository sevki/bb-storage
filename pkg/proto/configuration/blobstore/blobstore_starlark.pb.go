// Code generated by protoc-gen-starlark-go. DO NOT EDIT.

package blobstore

import (
	fmt "fmt"

	configuration "github.com/buildbarn/bb-storage/pkg/proto/configuration"
	blockdevice "github.com/buildbarn/bb-storage/pkg/proto/configuration/blockdevice"
	aws "github.com/buildbarn/bb-storage/pkg/proto/configuration/cloud/aws"
	digest "github.com/buildbarn/bb-storage/pkg/proto/configuration/digest"
	grpc "github.com/buildbarn/bb-storage/pkg/proto/configuration/grpc"
	tls "github.com/buildbarn/bb-storage/pkg/proto/configuration/tls"
	starlarkutil "github.com/buildbarn/bb-storage/pkg/starlarkutil"
	time "go.starlark.net/lib/time"
	starlark "go.starlark.net/starlark"
	_ "google.golang.org/genproto/googleapis/rpc/status"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/emptypb"
)

type BlobstoreConfigurationStarlark struct {
	ContentAddressableStorage *BlobAccessConfigurationStarlark
	ActionCache               *BlobAccessConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.BlobstoreConfiguration", new(BlobstoreConfigurationStarlark))
}

var (
	_ starlark.Value    = (*BlobstoreConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*BlobstoreConfigurationStarlark)(nil)
)

func (x *BlobstoreConfigurationStarlark) String() string {
	if x == nil {
		return "BlobstoreConfiguration{}"
	}
	return fmt.Sprintf("BlobstoreConfiguration{"+
		"contentAddressableStorage= %s"+
		", actionCache= %s"+
		"}",
		x.ContentAddressableStorage,
		x.ActionCache,
	)
}

func (x *BlobstoreConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.BlobstoreConfiguration"
}
func (x *BlobstoreConfigurationStarlark) Freeze()               {}
func (x *BlobstoreConfigurationStarlark) Truth() starlark.Bool  { return true }
func (x *BlobstoreConfigurationStarlark) Hash() (uint32, error) { return 0, fmt.Errorf("un-hashable") }
func (x *BlobstoreConfigurationStarlark) AttrNames() []string {
	return []string{
		"contentAddressableStorage", "content_addressable_storage",
		"actionCache", "action_cache",
	}
}

func (x *BlobstoreConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "contentAddressableStorage", "content_addressable_storage":
		return x.ContentAddressableStorage, nil
	case "actionCache", "action_cache":
		return x.ActionCache, nil
	default:
		return nil, nil
	}
}

func (x *BlobstoreConfiguration) ToStarlark() *BlobstoreConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &BlobstoreConfigurationStarlark{
		ContentAddressableStorage: x.GetContentAddressableStorage().ToStarlark(),
		ActionCache:               x.GetActionCache().ToStarlark(),
	}
}

func (x *BlobstoreConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "contentAddressableStorage", "content_addressable_storage":
		x.ContentAddressableStorage = val.(*BlobAccessConfigurationStarlark)
	case "actionCache", "action_cache":
		x.ActionCache = val.(*BlobAccessConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type BlobAccessConfigurationStarlark struct {
	Backend                   starlark.Value
	Redis                     *RedisBlobAccessConfigurationStarlark
	Http                      *HTTPBlobAccessConfigurationStarlark
	ReadCaching               *ReadCachingBlobAccessConfigurationStarlark
	SizeDistinguishing        *SizeDistinguishingBlobAccessConfigurationStarlark
	Grpc                      *grpc.ClientConfigurationStarlark
	Error                     *starlarkutil.Status
	Sharding                  *ShardingBlobAccessConfigurationStarlark
	Mirrored                  *MirroredBlobAccessConfigurationStarlark
	Local                     *LocalBlobAccessConfigurationStarlark
	ExistenceCaching          *ExistenceCachingBlobAccessConfigurationStarlark
	CompletenessChecking      *BlobAccessConfigurationStarlark
	ReadFallback              *ReadFallbackBlobAccessConfigurationStarlark
	ReferenceExpanding        *ReferenceExpandingBlobAccessConfigurationStarlark
	Demultiplexing            *DemultiplexingBlobAccessConfigurationStarlark
	HierarchicalInstanceNames *BlobAccessConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.BlobAccessConfiguration", new(BlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*BlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*BlobAccessConfigurationStarlark)(nil)
)

func (x *BlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "BlobAccessConfiguration{}"
	}
	return fmt.Sprintf("BlobAccessConfiguration{"+
		"backend= %s"+
		"redis= %s"+
		", http= %s"+
		", readCaching= %s"+
		", sizeDistinguishing= %s"+
		", grpc= %s"+
		", error= %s"+
		", sharding= %s"+
		", mirrored= %s"+
		", local= %s"+
		", existenceCaching= %s"+
		", completenessChecking= %s"+
		", readFallback= %s"+
		", referenceExpanding= %s"+
		", demultiplexing= %s"+
		", hierarchicalInstanceNames= %s"+
		"}",
		x.Backend,
		x.Redis,
		x.Http,
		x.ReadCaching,
		x.SizeDistinguishing,
		x.Grpc,
		x.Error,
		x.Sharding,
		x.Mirrored,
		x.Local,
		x.ExistenceCaching,
		x.CompletenessChecking,
		x.ReadFallback,
		x.ReferenceExpanding,
		x.Demultiplexing,
		x.HierarchicalInstanceNames,
	)
}

func (x *BlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.BlobAccessConfiguration"
}
func (x *BlobAccessConfigurationStarlark) Freeze()               {}
func (x *BlobAccessConfigurationStarlark) Truth() starlark.Bool  { return true }
func (x *BlobAccessConfigurationStarlark) Hash() (uint32, error) { return 0, fmt.Errorf("un-hashable") }
func (x *BlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"backend",
		"redis",
		"http",
		"readCaching", "read_caching",
		"sizeDistinguishing", "size_distinguishing",
		"grpc",
		"error",
		"sharding",
		"mirrored",
		"local",
		"existenceCaching", "existence_caching",
		"completenessChecking", "completeness_checking",
		"readFallback", "read_fallback",
		"referenceExpanding", "reference_expanding",
		"demultiplexing",
		"hierarchicalInstanceNames", "hierarchical_instance_names",
	}
}

func (x *BlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "backend":
		return x.Backend, nil
	case "redis":
		return x.Redis, nil
	case "http":
		return x.Http, nil
	case "readCaching", "read_caching":
		return x.ReadCaching, nil
	case "sizeDistinguishing", "size_distinguishing":
		return x.SizeDistinguishing, nil
	case "grpc":
		return x.Grpc, nil
	case "error":
		return x.Error, nil
	case "sharding":
		return x.Sharding, nil
	case "mirrored":
		return x.Mirrored, nil
	case "local":
		return x.Local, nil
	case "existenceCaching", "existence_caching":
		return x.ExistenceCaching, nil
	case "completenessChecking", "completeness_checking":
		return x.CompletenessChecking, nil
	case "readFallback", "read_fallback":
		return x.ReadFallback, nil
	case "referenceExpanding", "reference_expanding":
		return x.ReferenceExpanding, nil
	case "demultiplexing":
		return x.Demultiplexing, nil
	case "hierarchicalInstanceNames", "hierarchical_instance_names":
		return x.HierarchicalInstanceNames, nil
	default:
		return nil, nil
	}
}

func (x *BlobAccessConfiguration) ToStarlark() *BlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	var oneof_Backend starlark.Value
	switch x.Backend.(type) {
	case *BlobAccessConfiguration_Redis:
		oneof_Backend = x.GetRedis().ToStarlark()
	case *BlobAccessConfiguration_Http:
		oneof_Backend = x.GetHttp().ToStarlark()
	case *BlobAccessConfiguration_ReadCaching:
		oneof_Backend = x.GetReadCaching().ToStarlark()
	case *BlobAccessConfiguration_SizeDistinguishing:
		oneof_Backend = x.GetSizeDistinguishing().ToStarlark()
	case *BlobAccessConfiguration_Grpc:
		oneof_Backend = x.GetGrpc().ToStarlark()
	case *BlobAccessConfiguration_Error:
		oneof_Backend = starlarkutil.ToStatus(x.GetError())
	case *BlobAccessConfiguration_Sharding:
		oneof_Backend = x.GetSharding().ToStarlark()
	case *BlobAccessConfiguration_Mirrored:
		oneof_Backend = x.GetMirrored().ToStarlark()
	case *BlobAccessConfiguration_Local:
		oneof_Backend = x.GetLocal().ToStarlark()
	case *BlobAccessConfiguration_ExistenceCaching:
		oneof_Backend = x.GetExistenceCaching().ToStarlark()
	case *BlobAccessConfiguration_CompletenessChecking:
		oneof_Backend = x.GetCompletenessChecking().ToStarlark()
	case *BlobAccessConfiguration_ReadFallback:
		oneof_Backend = x.GetReadFallback().ToStarlark()
	case *BlobAccessConfiguration_ReferenceExpanding:
		oneof_Backend = x.GetReferenceExpanding().ToStarlark()
	case *BlobAccessConfiguration_Demultiplexing:
		oneof_Backend = x.GetDemultiplexing().ToStarlark()
	case *BlobAccessConfiguration_HierarchicalInstanceNames:
		oneof_Backend = x.GetHierarchicalInstanceNames().ToStarlark()
	default:
		oneof_Backend = starlark.None
	}

	return &BlobAccessConfigurationStarlark{
		Backend:                   oneof_Backend,
		Redis:                     x.GetRedis().ToStarlark(),
		Http:                      x.GetHttp().ToStarlark(),
		ReadCaching:               x.GetReadCaching().ToStarlark(),
		SizeDistinguishing:        x.GetSizeDistinguishing().ToStarlark(),
		Grpc:                      x.GetGrpc().ToStarlark(),
		Error:                     starlarkutil.ToStatus(x.GetError()),
		Sharding:                  x.GetSharding().ToStarlark(),
		Mirrored:                  x.GetMirrored().ToStarlark(),
		Local:                     x.GetLocal().ToStarlark(),
		ExistenceCaching:          x.GetExistenceCaching().ToStarlark(),
		CompletenessChecking:      x.GetCompletenessChecking().ToStarlark(),
		ReadFallback:              x.GetReadFallback().ToStarlark(),
		ReferenceExpanding:        x.GetReferenceExpanding().ToStarlark(),
		Demultiplexing:            x.GetDemultiplexing().ToStarlark(),
		HierarchicalInstanceNames: x.GetHierarchicalInstanceNames().ToStarlark(),
	}
}

func (x *BlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "backend":
		x.Backend = val.(*RedisBlobAccessConfigurationStarlark)
	case "redis":
		x.Redis = val.(*RedisBlobAccessConfigurationStarlark)
	case "http":
		x.Http = val.(*HTTPBlobAccessConfigurationStarlark)
	case "readCaching", "read_caching":
		x.ReadCaching = val.(*ReadCachingBlobAccessConfigurationStarlark)
	case "sizeDistinguishing", "size_distinguishing":
		x.SizeDistinguishing = val.(*SizeDistinguishingBlobAccessConfigurationStarlark)
	case "grpc":
		x.Grpc = val.(*grpc.ClientConfigurationStarlark)
	case "error":
		x.Error = val.(*starlarkutil.Status)
	case "sharding":
		x.Sharding = val.(*ShardingBlobAccessConfigurationStarlark)
	case "mirrored":
		x.Mirrored = val.(*MirroredBlobAccessConfigurationStarlark)
	case "local":
		x.Local = val.(*LocalBlobAccessConfigurationStarlark)
	case "existenceCaching", "existence_caching":
		x.ExistenceCaching = val.(*ExistenceCachingBlobAccessConfigurationStarlark)
	case "completenessChecking", "completeness_checking":
		x.CompletenessChecking = val.(*BlobAccessConfigurationStarlark)
	case "readFallback", "read_fallback":
		x.ReadFallback = val.(*ReadFallbackBlobAccessConfigurationStarlark)
	case "referenceExpanding", "reference_expanding":
		x.ReferenceExpanding = val.(*ReferenceExpandingBlobAccessConfigurationStarlark)
	case "demultiplexing":
		x.Demultiplexing = val.(*DemultiplexingBlobAccessConfigurationStarlark)
	case "hierarchicalInstanceNames", "hierarchical_instance_names":
		x.HierarchicalInstanceNames = val.(*BlobAccessConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type ReadCachingBlobAccessConfigurationStarlark struct {
	Slow       *BlobAccessConfigurationStarlark
	Fast       *BlobAccessConfigurationStarlark
	Replicator *BlobReplicatorConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ReadCachingBlobAccessConfiguration", new(ReadCachingBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ReadCachingBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ReadCachingBlobAccessConfigurationStarlark)(nil)
)

func (x *ReadCachingBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "ReadCachingBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("ReadCachingBlobAccessConfiguration{"+
		"slow= %s"+
		", fast= %s"+
		", replicator= %s"+
		"}",
		x.Slow,
		x.Fast,
		x.Replicator,
	)
}

func (x *ReadCachingBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ReadCachingBlobAccessConfiguration"
}
func (x *ReadCachingBlobAccessConfigurationStarlark) Freeze()              {}
func (x *ReadCachingBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ReadCachingBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ReadCachingBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"slow",
		"fast",
		"replicator",
	}
}

func (x *ReadCachingBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "slow":
		return x.Slow, nil
	case "fast":
		return x.Fast, nil
	case "replicator":
		return x.Replicator, nil
	default:
		return nil, nil
	}
}

func (x *ReadCachingBlobAccessConfiguration) ToStarlark() *ReadCachingBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &ReadCachingBlobAccessConfigurationStarlark{
		Slow:       x.GetSlow().ToStarlark(),
		Fast:       x.GetFast().ToStarlark(),
		Replicator: x.GetReplicator().ToStarlark(),
	}
}

func (x *ReadCachingBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "slow":
		x.Slow = val.(*BlobAccessConfigurationStarlark)
	case "fast":
		x.Fast = val.(*BlobAccessConfigurationStarlark)
	case "replicator":
		x.Replicator = val.(*BlobReplicatorConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type ClusteredRedisBlobAccessConfigurationStarlark struct {
	Endpoints           *starlark.List
	MaximumRetries      starlark.Int
	MinimumRetryBackoff time.Duration
	MaximumRetryBackoff time.Duration
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ClusteredRedisBlobAccessConfiguration", new(ClusteredRedisBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ClusteredRedisBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ClusteredRedisBlobAccessConfigurationStarlark)(nil)
)

func (x *ClusteredRedisBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "ClusteredRedisBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("ClusteredRedisBlobAccessConfiguration{"+
		"endpoints= %s"+
		", maximumRetries= %s"+
		", minimumRetryBackoff= %s"+
		", maximumRetryBackoff= %s"+
		"}",
		x.Endpoints,
		x.MaximumRetries,
		x.MinimumRetryBackoff,
		x.MaximumRetryBackoff,
	)
}

func (x *ClusteredRedisBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ClusteredRedisBlobAccessConfiguration"
}
func (x *ClusteredRedisBlobAccessConfigurationStarlark) Freeze()              {}
func (x *ClusteredRedisBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ClusteredRedisBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ClusteredRedisBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"endpoints",
		"maximumRetries", "maximum_retries",
		"minimumRetryBackoff", "minimum_retry_backoff",
		"maximumRetryBackoff", "maximum_retry_backoff",
	}
}

func (x *ClusteredRedisBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "endpoints":
		return x.Endpoints, nil
	case "maximumRetries", "maximum_retries":
		return x.MaximumRetries, nil
	case "minimumRetryBackoff", "minimum_retry_backoff":
		return x.MinimumRetryBackoff, nil
	case "maximumRetryBackoff", "maximum_retry_backoff":
		return x.MaximumRetryBackoff, nil
	default:
		return nil, nil
	}
}

func (x *ClusteredRedisBlobAccessConfiguration) ToStarlark() *ClusteredRedisBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	l_Endpoints := make([]starlark.Value, len(x.GetEndpoints()))
	for i, x := range x.GetEndpoints() {
		l_Endpoints[i] = starlark.String(x)
	}

	return &ClusteredRedisBlobAccessConfigurationStarlark{
		Endpoints:           starlark.NewList(l_Endpoints),
		MaximumRetries:      starlark.MakeUint64(uint64(x.GetMaximumRetries())),
		MinimumRetryBackoff: time.Duration(x.GetMinimumRetryBackoff().AsDuration()),
		MaximumRetryBackoff: time.Duration(x.GetMaximumRetryBackoff().AsDuration()),
	}
}

func (x *ClusteredRedisBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "endpoints":
		x.Endpoints = val.(*starlark.List)
	case "maximumRetries", "maximum_retries":
		x.MaximumRetries = val.(starlark.Int)
	case "minimumRetryBackoff", "minimum_retry_backoff":
		x.MinimumRetryBackoff = val.(time.Duration)
	case "maximumRetryBackoff", "maximum_retry_backoff":
		x.MaximumRetryBackoff = val.(time.Duration)
	default:
		return nil
	}
	return nil
}

type SingleRedisBlobAccessConfigurationStarlark struct {
	Endpoint starlark.String
	Db       starlark.Int
	Password starlark.String
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.SingleRedisBlobAccessConfiguration", new(SingleRedisBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*SingleRedisBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*SingleRedisBlobAccessConfigurationStarlark)(nil)
)

func (x *SingleRedisBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "SingleRedisBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("SingleRedisBlobAccessConfiguration{"+
		"endpoint= %s"+
		", db= %s"+
		", password= %s"+
		"}",
		x.Endpoint,
		x.Db,
		x.Password,
	)
}

func (x *SingleRedisBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.SingleRedisBlobAccessConfiguration"
}
func (x *SingleRedisBlobAccessConfigurationStarlark) Freeze()              {}
func (x *SingleRedisBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *SingleRedisBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *SingleRedisBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"endpoint",
		"db",
		"password",
	}
}

func (x *SingleRedisBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "endpoint":
		return x.Endpoint, nil
	case "db":
		return x.Db, nil
	case "password":
		return x.Password, nil
	default:
		return nil, nil
	}
}

func (x *SingleRedisBlobAccessConfiguration) ToStarlark() *SingleRedisBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &SingleRedisBlobAccessConfigurationStarlark{
		Endpoint: starlark.String(x.GetEndpoint()),
		Db:       starlark.MakeInt64(int64(x.GetDb())),
		Password: starlark.String(x.GetPassword()),
	}
}

func (x *SingleRedisBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "endpoint":
		x.Endpoint = val.(starlark.String)
	case "db":
		x.Db = val.(starlark.Int)
	case "password":
		x.Password = val.(starlark.String)
	default:
		return nil
	}
	return nil
}

type RedisBlobAccessConfigurationStarlark struct {
	Mode               starlark.Value
	Clustered          *ClusteredRedisBlobAccessConfigurationStarlark
	Single             *SingleRedisBlobAccessConfigurationStarlark
	Tls                *tls.ClientConfigurationStarlark
	ReplicationCount   starlark.Int
	ReplicationTimeout time.Duration
	DialTimeout        time.Duration
	ReadTimeout        time.Duration
	WriteTimeout       time.Duration
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.RedisBlobAccessConfiguration", new(RedisBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*RedisBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*RedisBlobAccessConfigurationStarlark)(nil)
)

func (x *RedisBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "RedisBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("RedisBlobAccessConfiguration{"+
		"mode= %s"+
		"clustered= %s"+
		", single= %s"+
		", tls= %s"+
		", replicationCount= %s"+
		", replicationTimeout= %s"+
		", dialTimeout= %s"+
		", readTimeout= %s"+
		", writeTimeout= %s"+
		"}",
		x.Mode,
		x.Clustered,
		x.Single,
		x.Tls,
		x.ReplicationCount,
		x.ReplicationTimeout,
		x.DialTimeout,
		x.ReadTimeout,
		x.WriteTimeout,
	)
}

func (x *RedisBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.RedisBlobAccessConfiguration"
}
func (x *RedisBlobAccessConfigurationStarlark) Freeze()              {}
func (x *RedisBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *RedisBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *RedisBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"mode",
		"clustered",
		"single",
		"tls",
		"replicationCount", "replication_count",
		"replicationTimeout", "replication_timeout",
		"dialTimeout", "dial_timeout",
		"readTimeout", "read_timeout",
		"writeTimeout", "write_timeout",
	}
}

func (x *RedisBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "mode":
		return x.Mode, nil
	case "clustered":
		return x.Clustered, nil
	case "single":
		return x.Single, nil
	case "tls":
		return x.Tls, nil
	case "replicationCount", "replication_count":
		return x.ReplicationCount, nil
	case "replicationTimeout", "replication_timeout":
		return x.ReplicationTimeout, nil
	case "dialTimeout", "dial_timeout":
		return x.DialTimeout, nil
	case "readTimeout", "read_timeout":
		return x.ReadTimeout, nil
	case "writeTimeout", "write_timeout":
		return x.WriteTimeout, nil
	default:
		return nil, nil
	}
}

func (x *RedisBlobAccessConfiguration) ToStarlark() *RedisBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	var oneof_Mode starlark.Value
	switch x.Mode.(type) {
	case *RedisBlobAccessConfiguration_Clustered:
		oneof_Mode = x.GetClustered().ToStarlark()
	case *RedisBlobAccessConfiguration_Single:
		oneof_Mode = x.GetSingle().ToStarlark()
	default:
		oneof_Mode = starlark.None
	}

	return &RedisBlobAccessConfigurationStarlark{
		Mode:               oneof_Mode,
		Clustered:          x.GetClustered().ToStarlark(),
		Single:             x.GetSingle().ToStarlark(),
		Tls:                x.GetTls().ToStarlark(),
		ReplicationCount:   starlark.MakeInt64(int64(x.GetReplicationCount())),
		ReplicationTimeout: time.Duration(x.GetReplicationTimeout().AsDuration()),
		DialTimeout:        time.Duration(x.GetDialTimeout().AsDuration()),
		ReadTimeout:        time.Duration(x.GetReadTimeout().AsDuration()),
		WriteTimeout:       time.Duration(x.GetWriteTimeout().AsDuration()),
	}
}

func (x *RedisBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "mode":
		x.Mode = val.(*ClusteredRedisBlobAccessConfigurationStarlark)
	case "clustered":
		x.Clustered = val.(*ClusteredRedisBlobAccessConfigurationStarlark)
	case "single":
		x.Single = val.(*SingleRedisBlobAccessConfigurationStarlark)
	case "tls":
		x.Tls = val.(*tls.ClientConfigurationStarlark)
	case "replicationCount", "replication_count":
		x.ReplicationCount = val.(starlark.Int)
	case "replicationTimeout", "replication_timeout":
		x.ReplicationTimeout = val.(time.Duration)
	case "dialTimeout", "dial_timeout":
		x.DialTimeout = val.(time.Duration)
	case "readTimeout", "read_timeout":
		x.ReadTimeout = val.(time.Duration)
	case "writeTimeout", "write_timeout":
		x.WriteTimeout = val.(time.Duration)
	default:
		return nil
	}
	return nil
}

type HTTPBlobAccessConfigurationStarlark struct {
	Address starlark.String
	Tls     *tls.ClientConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.HTTPBlobAccessConfiguration", new(HTTPBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*HTTPBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*HTTPBlobAccessConfigurationStarlark)(nil)
)

func (x *HTTPBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "HTTPBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("HTTPBlobAccessConfiguration{"+
		"address= %s"+
		", tls= %s"+
		"}",
		x.Address,
		x.Tls,
	)
}

func (x *HTTPBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.HTTPBlobAccessConfiguration"
}
func (x *HTTPBlobAccessConfigurationStarlark) Freeze()              {}
func (x *HTTPBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *HTTPBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *HTTPBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"address",
		"tls",
	}
}

func (x *HTTPBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "address":
		return x.Address, nil
	case "tls":
		return x.Tls, nil
	default:
		return nil, nil
	}
}

func (x *HTTPBlobAccessConfiguration) ToStarlark() *HTTPBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &HTTPBlobAccessConfigurationStarlark{
		Address: starlark.String(x.GetAddress()),
		Tls:     x.GetTls().ToStarlark(),
	}
}

func (x *HTTPBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "address":
		x.Address = val.(starlark.String)
	case "tls":
		x.Tls = val.(*tls.ClientConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type ShardingBlobAccessConfigurationStarlark struct {
	HashInitialization starlark.Int
	Shards             *starlark.List
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ShardingBlobAccessConfiguration", new(ShardingBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ShardingBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ShardingBlobAccessConfigurationStarlark)(nil)
)

func (x *ShardingBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "ShardingBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("ShardingBlobAccessConfiguration{"+
		"hashInitialization= %s"+
		", shards= %s"+
		"}",
		x.HashInitialization,
		x.Shards,
	)
}

func (x *ShardingBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ShardingBlobAccessConfiguration"
}
func (x *ShardingBlobAccessConfigurationStarlark) Freeze()              {}
func (x *ShardingBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ShardingBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ShardingBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"hashInitialization", "hash_initialization",
		"shards",
	}
}

func (x *ShardingBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "hashInitialization", "hash_initialization":
		return x.HashInitialization, nil
	case "shards":
		return x.Shards, nil
	default:
		return nil, nil
	}
}

func (x *ShardingBlobAccessConfiguration) ToStarlark() *ShardingBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	l_Shards := make([]starlark.Value, len(x.GetShards()))
	for i, x := range x.GetShards() {
		l_Shards[i] = x.ToStarlark()
	}

	return &ShardingBlobAccessConfigurationStarlark{
		HashInitialization: starlark.MakeUint64(uint64(x.GetHashInitialization())),
		Shards:             starlark.NewList(l_Shards),
	}
}

func (x *ShardingBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "hashInitialization", "hash_initialization":
		x.HashInitialization = val.(starlark.Int)
	case "shards":
		x.Shards = val.(*starlark.List)
	default:
		return nil
	}
	return nil
}

type SizeDistinguishingBlobAccessConfigurationStarlark struct {
	Small           *BlobAccessConfigurationStarlark
	Large           *BlobAccessConfigurationStarlark
	CutoffSizeBytes starlark.Int
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.SizeDistinguishingBlobAccessConfiguration", new(SizeDistinguishingBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*SizeDistinguishingBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*SizeDistinguishingBlobAccessConfigurationStarlark)(nil)
)

func (x *SizeDistinguishingBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "SizeDistinguishingBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("SizeDistinguishingBlobAccessConfiguration{"+
		"small= %s"+
		", large= %s"+
		", cutoffSizeBytes= %s"+
		"}",
		x.Small,
		x.Large,
		x.CutoffSizeBytes,
	)
}

func (x *SizeDistinguishingBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.SizeDistinguishingBlobAccessConfiguration"
}
func (x *SizeDistinguishingBlobAccessConfigurationStarlark) Freeze()              {}
func (x *SizeDistinguishingBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *SizeDistinguishingBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *SizeDistinguishingBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"small",
		"large",
		"cutoffSizeBytes", "cutoff_size_bytes",
	}
}

func (x *SizeDistinguishingBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "small":
		return x.Small, nil
	case "large":
		return x.Large, nil
	case "cutoffSizeBytes", "cutoff_size_bytes":
		return x.CutoffSizeBytes, nil
	default:
		return nil, nil
	}
}

func (x *SizeDistinguishingBlobAccessConfiguration) ToStarlark() *SizeDistinguishingBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &SizeDistinguishingBlobAccessConfigurationStarlark{
		Small:           x.GetSmall().ToStarlark(),
		Large:           x.GetLarge().ToStarlark(),
		CutoffSizeBytes: starlark.MakeInt64(int64(x.GetCutoffSizeBytes())),
	}
}

func (x *SizeDistinguishingBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "small":
		x.Small = val.(*BlobAccessConfigurationStarlark)
	case "large":
		x.Large = val.(*BlobAccessConfigurationStarlark)
	case "cutoffSizeBytes", "cutoff_size_bytes":
		x.CutoffSizeBytes = val.(starlark.Int)
	default:
		return nil
	}
	return nil
}

type MirroredBlobAccessConfigurationStarlark struct {
	BackendA       *BlobAccessConfigurationStarlark
	BackendB       *BlobAccessConfigurationStarlark
	ReplicatorAToB *BlobReplicatorConfigurationStarlark
	ReplicatorBToA *BlobReplicatorConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.MirroredBlobAccessConfiguration", new(MirroredBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*MirroredBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*MirroredBlobAccessConfigurationStarlark)(nil)
)

func (x *MirroredBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "MirroredBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("MirroredBlobAccessConfiguration{"+
		"backendA= %s"+
		", backendB= %s"+
		", replicatorAToB= %s"+
		", replicatorBToA= %s"+
		"}",
		x.BackendA,
		x.BackendB,
		x.ReplicatorAToB,
		x.ReplicatorBToA,
	)
}

func (x *MirroredBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.MirroredBlobAccessConfiguration"
}
func (x *MirroredBlobAccessConfigurationStarlark) Freeze()              {}
func (x *MirroredBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *MirroredBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *MirroredBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"backendA", "backend_a",
		"backendB", "backend_b",
		"replicatorAToB", "replicator_a_to_b",
		"replicatorBToA", "replicator_b_to_a",
	}
}

func (x *MirroredBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "backendA", "backend_a":
		return x.BackendA, nil
	case "backendB", "backend_b":
		return x.BackendB, nil
	case "replicatorAToB", "replicator_a_to_b":
		return x.ReplicatorAToB, nil
	case "replicatorBToA", "replicator_b_to_a":
		return x.ReplicatorBToA, nil
	default:
		return nil, nil
	}
}

func (x *MirroredBlobAccessConfiguration) ToStarlark() *MirroredBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &MirroredBlobAccessConfigurationStarlark{
		BackendA:       x.GetBackendA().ToStarlark(),
		BackendB:       x.GetBackendB().ToStarlark(),
		ReplicatorAToB: x.GetReplicatorAToB().ToStarlark(),
		ReplicatorBToA: x.GetReplicatorBToA().ToStarlark(),
	}
}

func (x *MirroredBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "backendA", "backend_a":
		x.BackendA = val.(*BlobAccessConfigurationStarlark)
	case "backendB", "backend_b":
		x.BackendB = val.(*BlobAccessConfigurationStarlark)
	case "replicatorAToB", "replicator_a_to_b":
		x.ReplicatorAToB = val.(*BlobReplicatorConfigurationStarlark)
	case "replicatorBToA", "replicator_b_to_a":
		x.ReplicatorBToA = val.(*BlobReplicatorConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type LocalBlobAccessConfigurationStarlark struct {
	KeyLocationMapBackend            starlark.Value
	KeyLocationMapInMemory           *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark
	KeyLocationMapOnBlockDevice      *blockdevice.ConfigurationStarlark
	KeyLocationMapMaximumGetAttempts starlark.Int
	KeyLocationMapMaximumPutAttempts starlark.Int
	OldBlocks                        starlark.Int
	CurrentBlocks                    starlark.Int
	NewBlocks                        starlark.Int
	BlocksBackend                    starlark.Value
	BlocksInMemory                   *LocalBlobAccessConfiguration_BlocksInMemoryStarlark
	BlocksOnBlockDevice              *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark
	Persistent                       *LocalBlobAccessConfiguration_PersistentStarlark
	HierarchicalInstanceNames        starlark.Bool
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.LocalBlobAccessConfiguration", new(LocalBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*LocalBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*LocalBlobAccessConfigurationStarlark)(nil)
)

func (x *LocalBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "LocalBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("LocalBlobAccessConfiguration{"+
		"key_location_map_backend= %s"+
		"keyLocationMapInMemory= %s"+
		", keyLocationMapOnBlockDevice= %s"+
		", keyLocationMapMaximumGetAttempts= %s"+
		", keyLocationMapMaximumPutAttempts= %s"+
		", oldBlocks= %s"+
		", currentBlocks= %s"+
		", newBlocks= %s"+
		", blocks_backend= %s"+
		", blocksInMemory= %s"+
		", blocksOnBlockDevice= %s"+
		", persistent= %s"+
		", hierarchicalInstanceNames= %s"+
		"}",
		x.KeyLocationMapBackend,
		x.KeyLocationMapInMemory,
		x.KeyLocationMapOnBlockDevice,
		x.KeyLocationMapMaximumGetAttempts,
		x.KeyLocationMapMaximumPutAttempts,
		x.OldBlocks,
		x.CurrentBlocks,
		x.NewBlocks,
		x.BlocksBackend,
		x.BlocksInMemory,
		x.BlocksOnBlockDevice,
		x.Persistent,
		x.HierarchicalInstanceNames,
	)
}

func (x *LocalBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.LocalBlobAccessConfiguration"
}
func (x *LocalBlobAccessConfigurationStarlark) Freeze()              {}
func (x *LocalBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *LocalBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *LocalBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"key_location_map_backend",
		"keyLocationMapInMemory", "key_location_map_in_memory",
		"keyLocationMapOnBlockDevice", "key_location_map_on_block_device",
		"keyLocationMapMaximumGetAttempts", "key_location_map_maximum_get_attempts",
		"keyLocationMapMaximumPutAttempts", "key_location_map_maximum_put_attempts",
		"oldBlocks", "old_blocks",
		"currentBlocks", "current_blocks",
		"newBlocks", "new_blocks",
		"blocks_backend",
		"blocksInMemory", "blocks_in_memory",
		"blocksOnBlockDevice", "blocks_on_block_device",
		"persistent",
		"hierarchicalInstanceNames", "hierarchical_instance_names",
	}
}

func (x *LocalBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "key_location_map_backend":
		return x.KeyLocationMapBackend, nil
	case "keyLocationMapInMemory", "key_location_map_in_memory":
		return x.KeyLocationMapInMemory, nil
	case "keyLocationMapOnBlockDevice", "key_location_map_on_block_device":
		return x.KeyLocationMapOnBlockDevice, nil
	case "keyLocationMapMaximumGetAttempts", "key_location_map_maximum_get_attempts":
		return x.KeyLocationMapMaximumGetAttempts, nil
	case "keyLocationMapMaximumPutAttempts", "key_location_map_maximum_put_attempts":
		return x.KeyLocationMapMaximumPutAttempts, nil
	case "oldBlocks", "old_blocks":
		return x.OldBlocks, nil
	case "currentBlocks", "current_blocks":
		return x.CurrentBlocks, nil
	case "newBlocks", "new_blocks":
		return x.NewBlocks, nil
	case "blocks_backend":
		return x.BlocksBackend, nil
	case "blocksInMemory", "blocks_in_memory":
		return x.BlocksInMemory, nil
	case "blocksOnBlockDevice", "blocks_on_block_device":
		return x.BlocksOnBlockDevice, nil
	case "persistent":
		return x.Persistent, nil
	case "hierarchicalInstanceNames", "hierarchical_instance_names":
		return x.HierarchicalInstanceNames, nil
	default:
		return nil, nil
	}
}

func (x *LocalBlobAccessConfiguration) ToStarlark() *LocalBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	var oneof_KeyLocationMapBackend starlark.Value
	switch x.KeyLocationMapBackend.(type) {
	case *LocalBlobAccessConfiguration_KeyLocationMapInMemory_:
		oneof_KeyLocationMapBackend = x.GetKeyLocationMapInMemory().ToStarlark()
	case *LocalBlobAccessConfiguration_KeyLocationMapOnBlockDevice:
		oneof_KeyLocationMapBackend = x.GetKeyLocationMapOnBlockDevice().ToStarlark()
	default:
		oneof_KeyLocationMapBackend = starlark.None
	}

	var oneof_BlocksBackend starlark.Value
	switch x.BlocksBackend.(type) {
	case *LocalBlobAccessConfiguration_BlocksInMemory_:
		oneof_BlocksBackend = x.GetBlocksInMemory().ToStarlark()
	case *LocalBlobAccessConfiguration_BlocksOnBlockDevice_:
		oneof_BlocksBackend = x.GetBlocksOnBlockDevice().ToStarlark()
	default:
		oneof_BlocksBackend = starlark.None
	}

	return &LocalBlobAccessConfigurationStarlark{
		KeyLocationMapBackend:            oneof_KeyLocationMapBackend,
		KeyLocationMapInMemory:           x.GetKeyLocationMapInMemory().ToStarlark(),
		KeyLocationMapOnBlockDevice:      x.GetKeyLocationMapOnBlockDevice().ToStarlark(),
		KeyLocationMapMaximumGetAttempts: starlark.MakeUint64(uint64(x.GetKeyLocationMapMaximumGetAttempts())),
		KeyLocationMapMaximumPutAttempts: starlark.MakeInt64(int64(x.GetKeyLocationMapMaximumPutAttempts())),
		OldBlocks:                        starlark.MakeInt64(int64(x.GetOldBlocks())),
		CurrentBlocks:                    starlark.MakeInt64(int64(x.GetCurrentBlocks())),
		NewBlocks:                        starlark.MakeInt64(int64(x.GetNewBlocks())),
		BlocksBackend:                    oneof_BlocksBackend,
		BlocksInMemory:                   x.GetBlocksInMemory().ToStarlark(),
		BlocksOnBlockDevice:              x.GetBlocksOnBlockDevice().ToStarlark(),
		Persistent:                       x.GetPersistent().ToStarlark(),
		HierarchicalInstanceNames:        starlark.Bool(x.GetHierarchicalInstanceNames()),
	}
}

func (x *LocalBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "key_location_map_backend":
		x.KeyLocationMapBackend = val.(*LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark)
	case "keyLocationMapInMemory", "key_location_map_in_memory":
		x.KeyLocationMapInMemory = val.(*LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark)
	case "keyLocationMapOnBlockDevice", "key_location_map_on_block_device":
		x.KeyLocationMapOnBlockDevice = val.(*blockdevice.ConfigurationStarlark)
	case "keyLocationMapMaximumGetAttempts", "key_location_map_maximum_get_attempts":
		x.KeyLocationMapMaximumGetAttempts = val.(starlark.Int)
	case "keyLocationMapMaximumPutAttempts", "key_location_map_maximum_put_attempts":
		x.KeyLocationMapMaximumPutAttempts = val.(starlark.Int)
	case "oldBlocks", "old_blocks":
		x.OldBlocks = val.(starlark.Int)
	case "currentBlocks", "current_blocks":
		x.CurrentBlocks = val.(starlark.Int)
	case "newBlocks", "new_blocks":
		x.NewBlocks = val.(starlark.Int)
	case "blocks_backend":
		x.BlocksBackend = val.(*LocalBlobAccessConfiguration_BlocksInMemoryStarlark)
	case "blocksInMemory", "blocks_in_memory":
		x.BlocksInMemory = val.(*LocalBlobAccessConfiguration_BlocksInMemoryStarlark)
	case "blocksOnBlockDevice", "blocks_on_block_device":
		x.BlocksOnBlockDevice = val.(*LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark)
	case "persistent":
		x.Persistent = val.(*LocalBlobAccessConfiguration_PersistentStarlark)
	case "hierarchicalInstanceNames", "hierarchical_instance_names":
		x.HierarchicalInstanceNames = val.(starlark.Bool)
	default:
		return nil
	}
	return nil
}

type ExistenceCachingBlobAccessConfigurationStarlark struct {
	Backend        *BlobAccessConfigurationStarlark
	ExistenceCache *digest.ExistenceCacheConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ExistenceCachingBlobAccessConfiguration", new(ExistenceCachingBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ExistenceCachingBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ExistenceCachingBlobAccessConfigurationStarlark)(nil)
)

func (x *ExistenceCachingBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "ExistenceCachingBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("ExistenceCachingBlobAccessConfiguration{"+
		"backend= %s"+
		", existenceCache= %s"+
		"}",
		x.Backend,
		x.ExistenceCache,
	)
}

func (x *ExistenceCachingBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ExistenceCachingBlobAccessConfiguration"
}
func (x *ExistenceCachingBlobAccessConfigurationStarlark) Freeze()              {}
func (x *ExistenceCachingBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ExistenceCachingBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ExistenceCachingBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"backend",
		"existenceCache", "existence_cache",
	}
}

func (x *ExistenceCachingBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "backend":
		return x.Backend, nil
	case "existenceCache", "existence_cache":
		return x.ExistenceCache, nil
	default:
		return nil, nil
	}
}

func (x *ExistenceCachingBlobAccessConfiguration) ToStarlark() *ExistenceCachingBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &ExistenceCachingBlobAccessConfigurationStarlark{
		Backend:        x.GetBackend().ToStarlark(),
		ExistenceCache: x.GetExistenceCache().ToStarlark(),
	}
}

func (x *ExistenceCachingBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "backend":
		x.Backend = val.(*BlobAccessConfigurationStarlark)
	case "existenceCache", "existence_cache":
		x.ExistenceCache = val.(*digest.ExistenceCacheConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type ReadFallbackBlobAccessConfigurationStarlark struct {
	Primary    *BlobAccessConfigurationStarlark
	Secondary  *BlobAccessConfigurationStarlark
	Replicator *BlobReplicatorConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ReadFallbackBlobAccessConfiguration", new(ReadFallbackBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ReadFallbackBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ReadFallbackBlobAccessConfigurationStarlark)(nil)
)

func (x *ReadFallbackBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "ReadFallbackBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("ReadFallbackBlobAccessConfiguration{"+
		"primary= %s"+
		", secondary= %s"+
		", replicator= %s"+
		"}",
		x.Primary,
		x.Secondary,
		x.Replicator,
	)
}

func (x *ReadFallbackBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ReadFallbackBlobAccessConfiguration"
}
func (x *ReadFallbackBlobAccessConfigurationStarlark) Freeze()              {}
func (x *ReadFallbackBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ReadFallbackBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ReadFallbackBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"primary",
		"secondary",
		"replicator",
	}
}

func (x *ReadFallbackBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "primary":
		return x.Primary, nil
	case "secondary":
		return x.Secondary, nil
	case "replicator":
		return x.Replicator, nil
	default:
		return nil, nil
	}
}

func (x *ReadFallbackBlobAccessConfiguration) ToStarlark() *ReadFallbackBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &ReadFallbackBlobAccessConfigurationStarlark{
		Primary:    x.GetPrimary().ToStarlark(),
		Secondary:  x.GetSecondary().ToStarlark(),
		Replicator: x.GetReplicator().ToStarlark(),
	}
}

func (x *ReadFallbackBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "primary":
		x.Primary = val.(*BlobAccessConfigurationStarlark)
	case "secondary":
		x.Secondary = val.(*BlobAccessConfigurationStarlark)
	case "replicator":
		x.Replicator = val.(*BlobReplicatorConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type ReferenceExpandingBlobAccessConfigurationStarlark struct {
	IndirectContentAddressableStorage *BlobAccessConfigurationStarlark
	AwsSession                        *aws.SessionConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ReferenceExpandingBlobAccessConfiguration", new(ReferenceExpandingBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ReferenceExpandingBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ReferenceExpandingBlobAccessConfigurationStarlark)(nil)
)

func (x *ReferenceExpandingBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "ReferenceExpandingBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("ReferenceExpandingBlobAccessConfiguration{"+
		"indirectContentAddressableStorage= %s"+
		", awsSession= %s"+
		"}",
		x.IndirectContentAddressableStorage,
		x.AwsSession,
	)
}

func (x *ReferenceExpandingBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ReferenceExpandingBlobAccessConfiguration"
}
func (x *ReferenceExpandingBlobAccessConfigurationStarlark) Freeze()              {}
func (x *ReferenceExpandingBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ReferenceExpandingBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ReferenceExpandingBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"indirectContentAddressableStorage", "indirect_content_addressable_storage",
		"awsSession", "aws_session",
	}
}

func (x *ReferenceExpandingBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "indirectContentAddressableStorage", "indirect_content_addressable_storage":
		return x.IndirectContentAddressableStorage, nil
	case "awsSession", "aws_session":
		return x.AwsSession, nil
	default:
		return nil, nil
	}
}

func (x *ReferenceExpandingBlobAccessConfiguration) ToStarlark() *ReferenceExpandingBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &ReferenceExpandingBlobAccessConfigurationStarlark{
		IndirectContentAddressableStorage: x.GetIndirectContentAddressableStorage().ToStarlark(),
		AwsSession:                        x.GetAwsSession().ToStarlark(),
	}
}

func (x *ReferenceExpandingBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "indirectContentAddressableStorage", "indirect_content_addressable_storage":
		x.IndirectContentAddressableStorage = val.(*BlobAccessConfigurationStarlark)
	case "awsSession", "aws_session":
		x.AwsSession = val.(*aws.SessionConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type BlobReplicatorConfigurationStarlark struct {
	Mode          starlark.Value
	Local         starlarkutil.Empty
	Remote        *grpc.ClientConfigurationStarlark
	Queued        *QueuedBlobReplicatorConfigurationStarlark
	Noop          starlarkutil.Empty
	Deduplicating *BlobReplicatorConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.BlobReplicatorConfiguration", new(BlobReplicatorConfigurationStarlark))
}

var (
	_ starlark.Value    = (*BlobReplicatorConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*BlobReplicatorConfigurationStarlark)(nil)
)

func (x *BlobReplicatorConfigurationStarlark) String() string {
	if x == nil {
		return "BlobReplicatorConfiguration{}"
	}
	return fmt.Sprintf("BlobReplicatorConfiguration{"+
		"mode= %s"+
		"local= %s"+
		", remote= %s"+
		", queued= %s"+
		", noop= %s"+
		", deduplicating= %s"+
		"}",
		x.Mode,
		x.Local,
		x.Remote,
		x.Queued,
		x.Noop,
		x.Deduplicating,
	)
}

func (x *BlobReplicatorConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.BlobReplicatorConfiguration"
}
func (x *BlobReplicatorConfigurationStarlark) Freeze()              {}
func (x *BlobReplicatorConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *BlobReplicatorConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *BlobReplicatorConfigurationStarlark) AttrNames() []string {
	return []string{
		"mode",
		"local",
		"remote",
		"queued",
		"noop",
		"deduplicating",
	}
}

func (x *BlobReplicatorConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "mode":
		return x.Mode, nil
	case "local":
		return x.Local, nil
	case "remote":
		return x.Remote, nil
	case "queued":
		return x.Queued, nil
	case "noop":
		return x.Noop, nil
	case "deduplicating":
		return x.Deduplicating, nil
	default:
		return nil, nil
	}
}

func (x *BlobReplicatorConfiguration) ToStarlark() *BlobReplicatorConfigurationStarlark {
	if x == nil {
		return nil
	}

	var oneof_Mode starlark.Value
	switch x.Mode.(type) {
	case *BlobReplicatorConfiguration_Local:
		oneof_Mode = starlarkutil.ToEmpty(x.GetLocal())
	case *BlobReplicatorConfiguration_Remote:
		oneof_Mode = x.GetRemote().ToStarlark()
	case *BlobReplicatorConfiguration_Queued:
		oneof_Mode = x.GetQueued().ToStarlark()
	case *BlobReplicatorConfiguration_Noop:
		oneof_Mode = starlarkutil.ToEmpty(x.GetNoop())
	case *BlobReplicatorConfiguration_Deduplicating:
		oneof_Mode = x.GetDeduplicating().ToStarlark()
	default:
		oneof_Mode = starlark.None
	}

	return &BlobReplicatorConfigurationStarlark{
		Mode:          oneof_Mode,
		Local:         starlarkutil.ToEmpty(x.GetLocal()),
		Remote:        x.GetRemote().ToStarlark(),
		Queued:        x.GetQueued().ToStarlark(),
		Noop:          starlarkutil.ToEmpty(x.GetNoop()),
		Deduplicating: x.GetDeduplicating().ToStarlark(),
	}
}

func (x *BlobReplicatorConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "mode":
		x.Mode = val.(starlarkutil.Empty)
	case "local":
		x.Local = val.(starlarkutil.Empty)
	case "remote":
		x.Remote = val.(*grpc.ClientConfigurationStarlark)
	case "queued":
		x.Queued = val.(*QueuedBlobReplicatorConfigurationStarlark)
	case "noop":
		x.Noop = val.(starlarkutil.Empty)
	case "deduplicating":
		x.Deduplicating = val.(*BlobReplicatorConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type QueuedBlobReplicatorConfigurationStarlark struct {
	Base           *BlobReplicatorConfigurationStarlark
	ExistenceCache *digest.ExistenceCacheConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.QueuedBlobReplicatorConfiguration", new(QueuedBlobReplicatorConfigurationStarlark))
}

var (
	_ starlark.Value    = (*QueuedBlobReplicatorConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*QueuedBlobReplicatorConfigurationStarlark)(nil)
)

func (x *QueuedBlobReplicatorConfigurationStarlark) String() string {
	if x == nil {
		return "QueuedBlobReplicatorConfiguration{}"
	}
	return fmt.Sprintf("QueuedBlobReplicatorConfiguration{"+
		"base= %s"+
		", existenceCache= %s"+
		"}",
		x.Base,
		x.ExistenceCache,
	)
}

func (x *QueuedBlobReplicatorConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.QueuedBlobReplicatorConfiguration"
}
func (x *QueuedBlobReplicatorConfigurationStarlark) Freeze()              {}
func (x *QueuedBlobReplicatorConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *QueuedBlobReplicatorConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *QueuedBlobReplicatorConfigurationStarlark) AttrNames() []string {
	return []string{
		"base",
		"existenceCache", "existence_cache",
	}
}

func (x *QueuedBlobReplicatorConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "base":
		return x.Base, nil
	case "existenceCache", "existence_cache":
		return x.ExistenceCache, nil
	default:
		return nil, nil
	}
}

func (x *QueuedBlobReplicatorConfiguration) ToStarlark() *QueuedBlobReplicatorConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &QueuedBlobReplicatorConfigurationStarlark{
		Base:           x.GetBase().ToStarlark(),
		ExistenceCache: x.GetExistenceCache().ToStarlark(),
	}
}

func (x *QueuedBlobReplicatorConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "base":
		x.Base = val.(*BlobReplicatorConfigurationStarlark)
	case "existenceCache", "existence_cache":
		x.ExistenceCache = val.(*digest.ExistenceCacheConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type DemultiplexingBlobAccessConfigurationStarlark struct {
	InstanceNamePrefixes *starlark.Dict
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.DemultiplexingBlobAccessConfiguration", new(DemultiplexingBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*DemultiplexingBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*DemultiplexingBlobAccessConfigurationStarlark)(nil)
)

func (x *DemultiplexingBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "DemultiplexingBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("DemultiplexingBlobAccessConfiguration{"+
		"instanceNamePrefixes= %s"+
		"}",
		x.InstanceNamePrefixes,
	)
}

func (x *DemultiplexingBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.DemultiplexingBlobAccessConfiguration"
}
func (x *DemultiplexingBlobAccessConfigurationStarlark) Freeze()              {}
func (x *DemultiplexingBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *DemultiplexingBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *DemultiplexingBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"instanceNamePrefixes", "instance_name_prefixes",
	}
}

func (x *DemultiplexingBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "instanceNamePrefixes", "instance_name_prefixes":
		return x.InstanceNamePrefixes, nil
	default:
		return nil, nil
	}
}

func (x *DemultiplexingBlobAccessConfiguration) ToStarlark() *DemultiplexingBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	var m_InstanceNamePrefixes *starlark.Dict
	if tm_InstanceNamePrefixes := x.GetInstanceNamePrefixes(); tm_InstanceNamePrefixes != nil {
		m_InstanceNamePrefixes = starlark.NewDict(len(tm_InstanceNamePrefixes))
		for k, v := range tm_InstanceNamePrefixes {
			_ = m_InstanceNamePrefixes.SetKey(starlark.String(k), v.ToStarlark())
		}
	} else {
		m_InstanceNamePrefixes = starlark.NewDict(0)
	}

	return &DemultiplexingBlobAccessConfigurationStarlark{
		InstanceNamePrefixes: m_InstanceNamePrefixes,
	}
}

func (x *DemultiplexingBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "instanceNamePrefixes", "instance_name_prefixes":
		x.InstanceNamePrefixes = val.(*starlark.Dict)
	default:
		return nil
	}
	return nil
}

type DemultiplexedBlobAccessConfigurationStarlark struct {
	Backend               *BlobAccessConfigurationStarlark
	AddInstanceNamePrefix starlark.String
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.DemultiplexedBlobAccessConfiguration", new(DemultiplexedBlobAccessConfigurationStarlark))
}

var (
	_ starlark.Value    = (*DemultiplexedBlobAccessConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*DemultiplexedBlobAccessConfigurationStarlark)(nil)
)

func (x *DemultiplexedBlobAccessConfigurationStarlark) String() string {
	if x == nil {
		return "DemultiplexedBlobAccessConfiguration{}"
	}
	return fmt.Sprintf("DemultiplexedBlobAccessConfiguration{"+
		"backend= %s"+
		", addInstanceNamePrefix= %s"+
		"}",
		x.Backend,
		x.AddInstanceNamePrefix,
	)
}

func (x *DemultiplexedBlobAccessConfigurationStarlark) Type() string {
	return "buildbarn.configuration.blobstore.DemultiplexedBlobAccessConfiguration"
}
func (x *DemultiplexedBlobAccessConfigurationStarlark) Freeze()              {}
func (x *DemultiplexedBlobAccessConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *DemultiplexedBlobAccessConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *DemultiplexedBlobAccessConfigurationStarlark) AttrNames() []string {
	return []string{
		"backend",
		"addInstanceNamePrefix", "add_instance_name_prefix",
	}
}

func (x *DemultiplexedBlobAccessConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "backend":
		return x.Backend, nil
	case "addInstanceNamePrefix", "add_instance_name_prefix":
		return x.AddInstanceNamePrefix, nil
	default:
		return nil, nil
	}
}

func (x *DemultiplexedBlobAccessConfiguration) ToStarlark() *DemultiplexedBlobAccessConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &DemultiplexedBlobAccessConfigurationStarlark{
		Backend:               x.GetBackend().ToStarlark(),
		AddInstanceNamePrefix: starlark.String(x.GetAddInstanceNamePrefix()),
	}
}

func (x *DemultiplexedBlobAccessConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "backend":
		x.Backend = val.(*BlobAccessConfigurationStarlark)
	case "addInstanceNamePrefix", "add_instance_name_prefix":
		x.AddInstanceNamePrefix = val.(starlark.String)
	default:
		return nil
	}
	return nil
}

type ShardingBlobAccessConfiguration_ShardStarlark struct {
	Backend *BlobAccessConfigurationStarlark
	Weight  starlark.Int
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.ShardingBlobAccessConfiguration.Shard", new(ShardingBlobAccessConfiguration_ShardStarlark))
}

var (
	_ starlark.Value    = (*ShardingBlobAccessConfiguration_ShardStarlark)(nil)
	_ starlark.HasAttrs = (*ShardingBlobAccessConfiguration_ShardStarlark)(nil)
)

func (x *ShardingBlobAccessConfiguration_ShardStarlark) String() string {
	if x == nil {
		return "Shard{}"
	}
	return fmt.Sprintf("Shard{"+
		"backend= %s"+
		", weight= %s"+
		"}",
		x.Backend,
		x.Weight,
	)
}

func (x *ShardingBlobAccessConfiguration_ShardStarlark) Type() string {
	return "buildbarn.configuration.blobstore.ShardingBlobAccessConfiguration.Shard"
}
func (x *ShardingBlobAccessConfiguration_ShardStarlark) Freeze()              {}
func (x *ShardingBlobAccessConfiguration_ShardStarlark) Truth() starlark.Bool { return true }
func (x *ShardingBlobAccessConfiguration_ShardStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ShardingBlobAccessConfiguration_ShardStarlark) AttrNames() []string {
	return []string{
		"backend",
		"weight",
	}
}

func (x *ShardingBlobAccessConfiguration_ShardStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "backend":
		return x.Backend, nil
	case "weight":
		return x.Weight, nil
	default:
		return nil, nil
	}
}

func (x *ShardingBlobAccessConfiguration_Shard) ToStarlark() *ShardingBlobAccessConfiguration_ShardStarlark {
	if x == nil {
		return nil
	}

	return &ShardingBlobAccessConfiguration_ShardStarlark{
		Backend: x.GetBackend().ToStarlark(),
		Weight:  starlark.MakeUint64(uint64(x.GetWeight())),
	}
}

func (x *ShardingBlobAccessConfiguration_ShardStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "backend":
		x.Backend = val.(*BlobAccessConfigurationStarlark)
	case "weight":
		x.Weight = val.(starlark.Int)
	default:
		return nil
	}
	return nil
}

type LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark struct {
	Entries starlark.Int
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.KeyLocationMapInMemory", new(LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark))
}

var (
	_ starlark.Value    = (*LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark)(nil)
	_ starlark.HasAttrs = (*LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark)(nil)
)

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) String() string {
	if x == nil {
		return "KeyLocationMapInMemory{}"
	}
	return fmt.Sprintf("KeyLocationMapInMemory{"+
		"entries= %s"+
		"}",
		x.Entries,
	)
}

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) Type() string {
	return "buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.KeyLocationMapInMemory"
}
func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) Freeze() {}
func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) Truth() starlark.Bool {
	return true
}

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) AttrNames() []string {
	return []string{
		"entries",
	}
}

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "entries":
		return x.Entries, nil
	default:
		return nil, nil
	}
}

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemory) ToStarlark() *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark {
	if x == nil {
		return nil
	}

	return &LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark{
		Entries: starlark.MakeInt64(int64(x.GetEntries())),
	}
}

func (x *LocalBlobAccessConfiguration_KeyLocationMapInMemoryStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "entries":
		x.Entries = val.(starlark.Int)
	default:
		return nil
	}
	return nil
}

type LocalBlobAccessConfiguration_BlocksInMemoryStarlark struct {
	BlockSizeBytes starlark.Int
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.BlocksInMemory", new(LocalBlobAccessConfiguration_BlocksInMemoryStarlark))
}

var (
	_ starlark.Value    = (*LocalBlobAccessConfiguration_BlocksInMemoryStarlark)(nil)
	_ starlark.HasAttrs = (*LocalBlobAccessConfiguration_BlocksInMemoryStarlark)(nil)
)

func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) String() string {
	if x == nil {
		return "BlocksInMemory{}"
	}
	return fmt.Sprintf("BlocksInMemory{"+
		"blockSizeBytes= %s"+
		"}",
		x.BlockSizeBytes,
	)
}

func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) Type() string {
	return "buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.BlocksInMemory"
}
func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) Freeze()              {}
func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) Truth() starlark.Bool { return true }
func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) AttrNames() []string {
	return []string{
		"blockSizeBytes", "block_size_bytes",
	}
}

func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "blockSizeBytes", "block_size_bytes":
		return x.BlockSizeBytes, nil
	default:
		return nil, nil
	}
}

func (x *LocalBlobAccessConfiguration_BlocksInMemory) ToStarlark() *LocalBlobAccessConfiguration_BlocksInMemoryStarlark {
	if x == nil {
		return nil
	}

	return &LocalBlobAccessConfiguration_BlocksInMemoryStarlark{
		BlockSizeBytes: starlark.MakeInt64(int64(x.GetBlockSizeBytes())),
	}
}

func (x *LocalBlobAccessConfiguration_BlocksInMemoryStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "blockSizeBytes", "block_size_bytes":
		x.BlockSizeBytes = val.(starlark.Int)
	default:
		return nil
	}
	return nil
}

type LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark struct {
	Source                       *blockdevice.ConfigurationStarlark
	SpareBlocks                  starlark.Int
	DataIntegrityValidationCache *digest.ExistenceCacheConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.BlocksOnBlockDevice", new(LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark))
}

var (
	_ starlark.Value    = (*LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark)(nil)
	_ starlark.HasAttrs = (*LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark)(nil)
)

func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) String() string {
	if x == nil {
		return "BlocksOnBlockDevice{}"
	}
	return fmt.Sprintf("BlocksOnBlockDevice{"+
		"source= %s"+
		", spareBlocks= %s"+
		", dataIntegrityValidationCache= %s"+
		"}",
		x.Source,
		x.SpareBlocks,
		x.DataIntegrityValidationCache,
	)
}

func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) Type() string {
	return "buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.BlocksOnBlockDevice"
}
func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) Freeze()              {}
func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) Truth() starlark.Bool { return true }
func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) AttrNames() []string {
	return []string{
		"source",
		"spareBlocks", "spare_blocks",
		"dataIntegrityValidationCache", "data_integrity_validation_cache",
	}
}

func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "source":
		return x.Source, nil
	case "spareBlocks", "spare_blocks":
		return x.SpareBlocks, nil
	case "dataIntegrityValidationCache", "data_integrity_validation_cache":
		return x.DataIntegrityValidationCache, nil
	default:
		return nil, nil
	}
}

func (x *LocalBlobAccessConfiguration_BlocksOnBlockDevice) ToStarlark() *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark {
	if x == nil {
		return nil
	}

	return &LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark{
		Source:                       x.GetSource().ToStarlark(),
		SpareBlocks:                  starlark.MakeInt64(int64(x.GetSpareBlocks())),
		DataIntegrityValidationCache: x.GetDataIntegrityValidationCache().ToStarlark(),
	}
}

func (x *LocalBlobAccessConfiguration_BlocksOnBlockDeviceStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "source":
		x.Source = val.(*blockdevice.ConfigurationStarlark)
	case "spareBlocks", "spare_blocks":
		x.SpareBlocks = val.(starlark.Int)
	case "dataIntegrityValidationCache", "data_integrity_validation_cache":
		x.DataIntegrityValidationCache = val.(*digest.ExistenceCacheConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type LocalBlobAccessConfiguration_PersistentStarlark struct {
	StateDirectoryPath   starlark.String
	MinimumEpochInterval time.Duration
}

func init() {
	configuration.Register("buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.Persistent", new(LocalBlobAccessConfiguration_PersistentStarlark))
}

var (
	_ starlark.Value    = (*LocalBlobAccessConfiguration_PersistentStarlark)(nil)
	_ starlark.HasAttrs = (*LocalBlobAccessConfiguration_PersistentStarlark)(nil)
)

func (x *LocalBlobAccessConfiguration_PersistentStarlark) String() string {
	if x == nil {
		return "Persistent{}"
	}
	return fmt.Sprintf("Persistent{"+
		"stateDirectoryPath= %s"+
		", minimumEpochInterval= %s"+
		"}",
		x.StateDirectoryPath,
		x.MinimumEpochInterval,
	)
}

func (x *LocalBlobAccessConfiguration_PersistentStarlark) Type() string {
	return "buildbarn.configuration.blobstore.LocalBlobAccessConfiguration.Persistent"
}
func (x *LocalBlobAccessConfiguration_PersistentStarlark) Freeze()              {}
func (x *LocalBlobAccessConfiguration_PersistentStarlark) Truth() starlark.Bool { return true }
func (x *LocalBlobAccessConfiguration_PersistentStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *LocalBlobAccessConfiguration_PersistentStarlark) AttrNames() []string {
	return []string{
		"stateDirectoryPath", "state_directory_path",
		"minimumEpochInterval", "minimum_epoch_interval",
	}
}

func (x *LocalBlobAccessConfiguration_PersistentStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "stateDirectoryPath", "state_directory_path":
		return x.StateDirectoryPath, nil
	case "minimumEpochInterval", "minimum_epoch_interval":
		return x.MinimumEpochInterval, nil
	default:
		return nil, nil
	}
}

func (x *LocalBlobAccessConfiguration_Persistent) ToStarlark() *LocalBlobAccessConfiguration_PersistentStarlark {
	if x == nil {
		return nil
	}

	return &LocalBlobAccessConfiguration_PersistentStarlark{
		StateDirectoryPath:   starlark.String(x.GetStateDirectoryPath()),
		MinimumEpochInterval: time.Duration(x.GetMinimumEpochInterval().AsDuration()),
	}
}

func (x *LocalBlobAccessConfiguration_PersistentStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "stateDirectoryPath", "state_directory_path":
		x.StateDirectoryPath = val.(starlark.String)
	case "minimumEpochInterval", "minimum_epoch_interval":
		x.MinimumEpochInterval = val.(time.Duration)
	default:
		return nil
	}
	return nil
}

// Code generated by protoc-gen-starlark-go. DO NOT EDIT.

package bb_storage

import (
	fmt "fmt"

	configuration "github.com/buildbarn/bb-storage/pkg/proto/configuration"
	auth "github.com/buildbarn/bb-storage/pkg/proto/configuration/auth"
	blobstore "github.com/buildbarn/bb-storage/pkg/proto/configuration/blobstore"
	_ "github.com/buildbarn/bb-storage/pkg/proto/configuration/builder"
	global "github.com/buildbarn/bb-storage/pkg/proto/configuration/global"
	_ "github.com/buildbarn/bb-storage/pkg/proto/configuration/grpc"
	starlark "go.starlark.net/starlark"
)

type ApplicationConfigurationStarlark struct {
	Blobstore                                    *blobstore.BlobstoreConfigurationStarlark
	GrpcServers                                  *starlark.List
	Schedulers                                   *starlark.Dict
	MaximumMessageSizeBytes                      starlark.Int
	Global                                       *global.ConfigurationStarlark
	IndirectContentAddressableStorage            *blobstore.BlobAccessConfigurationStarlark
	InitialSizeClassCache                        *blobstore.BlobAccessConfigurationStarlark
	ContentAddressableStorageAuthorizers         *ScannableAuthorizersConfigurationStarlark
	IndirectContentAddressableStorageAuthorizers *ScannableAuthorizersConfigurationStarlark
	ActionCacheAuthorizers                       *NonScannableAuthorizersConfigurationStarlark
	InitialSizeClassCacheAuthorizers             *NonScannableAuthorizersConfigurationStarlark
	ExecuteAuthorizer                            *auth.AuthorizerConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.bb_storage.ApplicationConfiguration", new(ApplicationConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ApplicationConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ApplicationConfigurationStarlark)(nil)
)

func (x *ApplicationConfigurationStarlark) String() string {
	if x == nil {
		return "ApplicationConfiguration{}"
	}
	return fmt.Sprintf("ApplicationConfiguration{"+
		"blobstore= %s"+
		", grpcServers= %s"+
		", schedulers= %s"+
		", maximumMessageSizeBytes= %s"+
		", global= %s"+
		", indirectContentAddressableStorage= %s"+
		", initialSizeClassCache= %s"+
		", contentAddressableStorageAuthorizers= %s"+
		", indirectContentAddressableStorageAuthorizers= %s"+
		", actionCacheAuthorizers= %s"+
		", initialSizeClassCacheAuthorizers= %s"+
		", executeAuthorizer= %s"+
		"}",
		x.Blobstore,
		x.GrpcServers,
		x.Schedulers,
		x.MaximumMessageSizeBytes,
		x.Global,
		x.IndirectContentAddressableStorage,
		x.InitialSizeClassCache,
		x.ContentAddressableStorageAuthorizers,
		x.IndirectContentAddressableStorageAuthorizers,
		x.ActionCacheAuthorizers,
		x.InitialSizeClassCacheAuthorizers,
		x.ExecuteAuthorizer,
	)
}

func (x *ApplicationConfigurationStarlark) Type() string {
	return "buildbarn.configuration.bb_storage.ApplicationConfiguration"
}
func (x *ApplicationConfigurationStarlark) Freeze()              {}
func (x *ApplicationConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ApplicationConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ApplicationConfigurationStarlark) AttrNames() []string {
	return []string{
		"blobstore",
		"grpcServers", "grpc_servers",
		"schedulers",
		"maximumMessageSizeBytes", "maximum_message_size_bytes",
		"global",
		"indirectContentAddressableStorage", "indirect_content_addressable_storage",
		"initialSizeClassCache", "initial_size_class_cache",
		"contentAddressableStorageAuthorizers", "content_addressable_storage_authorizers",
		"indirectContentAddressableStorageAuthorizers", "indirect_content_addressable_storage_authorizers",
		"actionCacheAuthorizers", "action_cache_authorizers",
		"initialSizeClassCacheAuthorizers", "initial_size_class_cache_authorizers",
		"executeAuthorizer", "execute_authorizer",
	}
}

func (x *ApplicationConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "blobstore":
		return x.Blobstore, nil
	case "grpcServers", "grpc_servers":
		return x.GrpcServers, nil
	case "schedulers":
		return x.Schedulers, nil
	case "maximumMessageSizeBytes", "maximum_message_size_bytes":
		return x.MaximumMessageSizeBytes, nil
	case "global":
		return x.Global, nil
	case "indirectContentAddressableStorage", "indirect_content_addressable_storage":
		return x.IndirectContentAddressableStorage, nil
	case "initialSizeClassCache", "initial_size_class_cache":
		return x.InitialSizeClassCache, nil
	case "contentAddressableStorageAuthorizers", "content_addressable_storage_authorizers":
		return x.ContentAddressableStorageAuthorizers, nil
	case "indirectContentAddressableStorageAuthorizers", "indirect_content_addressable_storage_authorizers":
		return x.IndirectContentAddressableStorageAuthorizers, nil
	case "actionCacheAuthorizers", "action_cache_authorizers":
		return x.ActionCacheAuthorizers, nil
	case "initialSizeClassCacheAuthorizers", "initial_size_class_cache_authorizers":
		return x.InitialSizeClassCacheAuthorizers, nil
	case "executeAuthorizer", "execute_authorizer":
		return x.ExecuteAuthorizer, nil
	default:
		return nil, nil
	}
}

func (x *ApplicationConfiguration) ToStarlark() *ApplicationConfigurationStarlark {
	if x == nil {
		return nil
	}

	l_GrpcServers := make([]starlark.Value, len(x.GetGrpcServers()))
	for i, x := range x.GetGrpcServers() {
		l_GrpcServers[i] = x.ToStarlark()
	}

	var m_Schedulers *starlark.Dict
	if tm_Schedulers := x.GetSchedulers(); tm_Schedulers != nil {
		m_Schedulers = starlark.NewDict(len(tm_Schedulers))
		for k, v := range tm_Schedulers {
			_ = m_Schedulers.SetKey(starlark.String(k), v.ToStarlark())
		}
	} else {
		m_Schedulers = starlark.NewDict(0)
	}

	return &ApplicationConfigurationStarlark{
		Blobstore:                            x.GetBlobstore().ToStarlark(),
		GrpcServers:                          starlark.NewList(l_GrpcServers),
		Schedulers:                           m_Schedulers,
		MaximumMessageSizeBytes:              starlark.MakeInt64(int64(x.GetMaximumMessageSizeBytes())),
		Global:                               x.GetGlobal().ToStarlark(),
		IndirectContentAddressableStorage:    x.GetIndirectContentAddressableStorage().ToStarlark(),
		InitialSizeClassCache:                x.GetInitialSizeClassCache().ToStarlark(),
		ContentAddressableStorageAuthorizers: x.GetContentAddressableStorageAuthorizers().ToStarlark(),
		IndirectContentAddressableStorageAuthorizers: x.GetIndirectContentAddressableStorageAuthorizers().ToStarlark(),
		ActionCacheAuthorizers:                       x.GetActionCacheAuthorizers().ToStarlark(),
		InitialSizeClassCacheAuthorizers:             x.GetInitialSizeClassCacheAuthorizers().ToStarlark(),
		ExecuteAuthorizer:                            x.GetExecuteAuthorizer().ToStarlark(),
	}
}

func (x *ApplicationConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "blobstore":
		x.Blobstore = val.(*blobstore.BlobstoreConfigurationStarlark)
	case "grpcServers", "grpc_servers":
		x.GrpcServers = val.(*starlark.List)
	case "schedulers":
		x.Schedulers = val.(*starlark.Dict)
	case "maximumMessageSizeBytes", "maximum_message_size_bytes":
		x.MaximumMessageSizeBytes = val.(starlark.Int)
	case "global":
		x.Global = val.(*global.ConfigurationStarlark)
	case "indirectContentAddressableStorage", "indirect_content_addressable_storage":
		x.IndirectContentAddressableStorage = val.(*blobstore.BlobAccessConfigurationStarlark)
	case "initialSizeClassCache", "initial_size_class_cache":
		x.InitialSizeClassCache = val.(*blobstore.BlobAccessConfigurationStarlark)
	case "contentAddressableStorageAuthorizers", "content_addressable_storage_authorizers":
		x.ContentAddressableStorageAuthorizers = val.(*ScannableAuthorizersConfigurationStarlark)
	case "indirectContentAddressableStorageAuthorizers", "indirect_content_addressable_storage_authorizers":
		x.IndirectContentAddressableStorageAuthorizers = val.(*ScannableAuthorizersConfigurationStarlark)
	case "actionCacheAuthorizers", "action_cache_authorizers":
		x.ActionCacheAuthorizers = val.(*NonScannableAuthorizersConfigurationStarlark)
	case "initialSizeClassCacheAuthorizers", "initial_size_class_cache_authorizers":
		x.InitialSizeClassCacheAuthorizers = val.(*NonScannableAuthorizersConfigurationStarlark)
	case "executeAuthorizer", "execute_authorizer":
		x.ExecuteAuthorizer = val.(*auth.AuthorizerConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type NonScannableAuthorizersConfigurationStarlark struct {
	Get *auth.AuthorizerConfigurationStarlark
	Put *auth.AuthorizerConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.bb_storage.NonScannableAuthorizersConfiguration", new(NonScannableAuthorizersConfigurationStarlark))
}

var (
	_ starlark.Value    = (*NonScannableAuthorizersConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*NonScannableAuthorizersConfigurationStarlark)(nil)
)

func (x *NonScannableAuthorizersConfigurationStarlark) String() string {
	if x == nil {
		return "NonScannableAuthorizersConfiguration{}"
	}
	return fmt.Sprintf("NonScannableAuthorizersConfiguration{"+
		"get= %s"+
		", put= %s"+
		"}",
		x.Get,
		x.Put,
	)
}

func (x *NonScannableAuthorizersConfigurationStarlark) Type() string {
	return "buildbarn.configuration.bb_storage.NonScannableAuthorizersConfiguration"
}
func (x *NonScannableAuthorizersConfigurationStarlark) Freeze()              {}
func (x *NonScannableAuthorizersConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *NonScannableAuthorizersConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *NonScannableAuthorizersConfigurationStarlark) AttrNames() []string {
	return []string{
		"get",
		"put",
	}
}

func (x *NonScannableAuthorizersConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "get":
		return x.Get, nil
	case "put":
		return x.Put, nil
	default:
		return nil, nil
	}
}

func (x *NonScannableAuthorizersConfiguration) ToStarlark() *NonScannableAuthorizersConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &NonScannableAuthorizersConfigurationStarlark{
		Get: x.GetGet().ToStarlark(),
		Put: x.GetPut().ToStarlark(),
	}
}

func (x *NonScannableAuthorizersConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "get":
		x.Get = val.(*auth.AuthorizerConfigurationStarlark)
	case "put":
		x.Put = val.(*auth.AuthorizerConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

type ScannableAuthorizersConfigurationStarlark struct {
	Get         *auth.AuthorizerConfigurationStarlark
	Put         *auth.AuthorizerConfigurationStarlark
	FindMissing *auth.AuthorizerConfigurationStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.bb_storage.ScannableAuthorizersConfiguration", new(ScannableAuthorizersConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ScannableAuthorizersConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ScannableAuthorizersConfigurationStarlark)(nil)
)

func (x *ScannableAuthorizersConfigurationStarlark) String() string {
	if x == nil {
		return "ScannableAuthorizersConfiguration{}"
	}
	return fmt.Sprintf("ScannableAuthorizersConfiguration{"+
		"get= %s"+
		", put= %s"+
		", findMissing= %s"+
		"}",
		x.Get,
		x.Put,
		x.FindMissing,
	)
}

func (x *ScannableAuthorizersConfigurationStarlark) Type() string {
	return "buildbarn.configuration.bb_storage.ScannableAuthorizersConfiguration"
}
func (x *ScannableAuthorizersConfigurationStarlark) Freeze()              {}
func (x *ScannableAuthorizersConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ScannableAuthorizersConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ScannableAuthorizersConfigurationStarlark) AttrNames() []string {
	return []string{
		"get",
		"put",
		"findMissing", "find_missing",
	}
}

func (x *ScannableAuthorizersConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "get":
		return x.Get, nil
	case "put":
		return x.Put, nil
	case "findMissing", "find_missing":
		return x.FindMissing, nil
	default:
		return nil, nil
	}
}

func (x *ScannableAuthorizersConfiguration) ToStarlark() *ScannableAuthorizersConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &ScannableAuthorizersConfigurationStarlark{
		Get:         x.GetGet().ToStarlark(),
		Put:         x.GetPut().ToStarlark(),
		FindMissing: x.GetFindMissing().ToStarlark(),
	}
}

func (x *ScannableAuthorizersConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "get":
		x.Get = val.(*auth.AuthorizerConfigurationStarlark)
	case "put":
		x.Put = val.(*auth.AuthorizerConfigurationStarlark)
	case "findMissing", "find_missing":
		x.FindMissing = val.(*auth.AuthorizerConfigurationStarlark)
	default:
		return nil
	}
	return nil
}

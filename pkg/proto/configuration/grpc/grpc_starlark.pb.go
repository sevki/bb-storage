// Code generated by protoc-gen-starlark-go. DO NOT EDIT.

package grpc

import (
	fmt "fmt"

	configuration "github.com/buildbarn/bb-storage/pkg/proto/configuration"
	tls "github.com/buildbarn/bb-storage/pkg/proto/configuration/tls"
	starlarkutil "github.com/buildbarn/bb-storage/pkg/starlarkutil"
	time "go.starlark.net/lib/time"
	starlark "go.starlark.net/starlark"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/emptypb"
)

type ClientConfigurationStarlark struct {
	Address                    starlark.String
	Tls                        *tls.ClientConfigurationStarlark
	Keepalive                  *ClientKeepaliveConfigurationStarlark
	ForwardMetadata            *starlark.List
	AddMetadata                *starlark.List
	Oauth                      *ClientOAuthConfigurationStarlark
	ForwardAndReuseMetadata    *starlark.List
	InitialWindowSizeBytes     starlark.Int
	InitialConnWindowSizeBytes starlark.Int
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.ClientConfiguration", new(ClientConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ClientConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ClientConfigurationStarlark)(nil)
)

func (x *ClientConfigurationStarlark) String() string {
	if x == nil {
		return "ClientConfiguration{}"
	}
	return fmt.Sprintf("ClientConfiguration{"+
		"address= %s"+
		", tls= %s"+
		", keepalive= %s"+
		", forwardMetadata= %s"+
		", addMetadata= %s"+
		", oauth= %s"+
		", forwardAndReuseMetadata= %s"+
		", initialWindowSizeBytes= %s"+
		", initialConnWindowSizeBytes= %s"+
		"}",
		x.Address,
		x.Tls,
		x.Keepalive,
		x.ForwardMetadata,
		x.AddMetadata,
		x.Oauth,
		x.ForwardAndReuseMetadata,
		x.InitialWindowSizeBytes,
		x.InitialConnWindowSizeBytes,
	)
}

func (x *ClientConfigurationStarlark) Type() string {
	return "buildbarn.configuration.grpc.ClientConfiguration"
}
func (x *ClientConfigurationStarlark) Freeze()               {}
func (x *ClientConfigurationStarlark) Truth() starlark.Bool  { return true }
func (x *ClientConfigurationStarlark) Hash() (uint32, error) { return 0, fmt.Errorf("un-hashable") }
func (x *ClientConfigurationStarlark) AttrNames() []string {
	return []string{
		"address",
		"tls",
		"keepalive",
		"forwardMetadata", "forward_metadata",
		"addMetadata", "add_metadata",
		"oauth",
		"forwardAndReuseMetadata", "forward_and_reuse_metadata",
		"initialWindowSizeBytes", "initial_window_size_bytes",
		"initialConnWindowSizeBytes", "initial_conn_window_size_bytes",
	}
}

func (x *ClientConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "address":
		return x.Address, nil
	case "tls":
		return x.Tls, nil
	case "keepalive":
		return x.Keepalive, nil
	case "forwardMetadata", "forward_metadata":
		return x.ForwardMetadata, nil
	case "addMetadata", "add_metadata":
		return x.AddMetadata, nil
	case "oauth":
		return x.Oauth, nil
	case "forwardAndReuseMetadata", "forward_and_reuse_metadata":
		return x.ForwardAndReuseMetadata, nil
	case "initialWindowSizeBytes", "initial_window_size_bytes":
		return x.InitialWindowSizeBytes, nil
	case "initialConnWindowSizeBytes", "initial_conn_window_size_bytes":
		return x.InitialConnWindowSizeBytes, nil
	default:
		return nil, nil
	}
}

func (x *ClientConfiguration) ToStarlark() *ClientConfigurationStarlark {
	if x == nil {
		return nil
	}

	l_ForwardMetadata := make([]starlark.Value, len(x.GetForwardMetadata()))
	for i, x := range x.GetForwardMetadata() {
		l_ForwardMetadata[i] = starlark.String(x)
	}

	l_AddMetadata := make([]starlark.Value, len(x.GetAddMetadata()))
	for i, x := range x.GetAddMetadata() {
		l_AddMetadata[i] = x.ToStarlark()
	}

	l_ForwardAndReuseMetadata := make([]starlark.Value, len(x.GetForwardAndReuseMetadata()))
	for i, x := range x.GetForwardAndReuseMetadata() {
		l_ForwardAndReuseMetadata[i] = starlark.String(x)
	}

	return &ClientConfigurationStarlark{
		Address:                    starlark.String(x.GetAddress()),
		Tls:                        x.GetTls().ToStarlark(),
		Keepalive:                  x.GetKeepalive().ToStarlark(),
		ForwardMetadata:            starlark.NewList(l_ForwardMetadata),
		AddMetadata:                starlark.NewList(l_AddMetadata),
		Oauth:                      x.GetOauth().ToStarlark(),
		ForwardAndReuseMetadata:    starlark.NewList(l_ForwardAndReuseMetadata),
		InitialWindowSizeBytes:     starlark.MakeInt64(int64(x.GetInitialWindowSizeBytes())),
		InitialConnWindowSizeBytes: starlark.MakeInt64(int64(x.GetInitialConnWindowSizeBytes())),
	}
}

func (x *ClientConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "address":
		x.Address = val.(starlark.String)
	case "tls":
		x.Tls = val.(*tls.ClientConfigurationStarlark)
	case "keepalive":
		x.Keepalive = val.(*ClientKeepaliveConfigurationStarlark)
	case "forwardMetadata", "forward_metadata":
		x.ForwardMetadata = val.(*starlark.List)
	case "addMetadata", "add_metadata":
		x.AddMetadata = val.(*starlark.List)
	case "oauth":
		x.Oauth = val.(*ClientOAuthConfigurationStarlark)
	case "forwardAndReuseMetadata", "forward_and_reuse_metadata":
		x.ForwardAndReuseMetadata = val.(*starlark.List)
	case "initialWindowSizeBytes", "initial_window_size_bytes":
		x.InitialWindowSizeBytes = val.(starlark.Int)
	case "initialConnWindowSizeBytes", "initial_conn_window_size_bytes":
		x.InitialConnWindowSizeBytes = val.(starlark.Int)
	default:
		return nil
	}
	return nil
}

type ClientKeepaliveConfigurationStarlark struct {
	Time                time.Duration
	Timeout             time.Duration
	PermitWithoutStream starlark.Bool
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.ClientKeepaliveConfiguration", new(ClientKeepaliveConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ClientKeepaliveConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ClientKeepaliveConfigurationStarlark)(nil)
)

func (x *ClientKeepaliveConfigurationStarlark) String() string {
	if x == nil {
		return "ClientKeepaliveConfiguration{}"
	}
	return fmt.Sprintf("ClientKeepaliveConfiguration{"+
		"time= %s"+
		", timeout= %s"+
		", permitWithoutStream= %s"+
		"}",
		x.Time,
		x.Timeout,
		x.PermitWithoutStream,
	)
}

func (x *ClientKeepaliveConfigurationStarlark) Type() string {
	return "buildbarn.configuration.grpc.ClientKeepaliveConfiguration"
}
func (x *ClientKeepaliveConfigurationStarlark) Freeze()              {}
func (x *ClientKeepaliveConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ClientKeepaliveConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ClientKeepaliveConfigurationStarlark) AttrNames() []string {
	return []string{
		"time",
		"timeout",
		"permitWithoutStream", "permit_without_stream",
	}
}

func (x *ClientKeepaliveConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "time":
		return x.Time, nil
	case "timeout":
		return x.Timeout, nil
	case "permitWithoutStream", "permit_without_stream":
		return x.PermitWithoutStream, nil
	default:
		return nil, nil
	}
}

func (x *ClientKeepaliveConfiguration) ToStarlark() *ClientKeepaliveConfigurationStarlark {
	if x == nil {
		return nil
	}

	return &ClientKeepaliveConfigurationStarlark{
		Time:                time.Duration(x.GetTime().AsDuration()),
		Timeout:             time.Duration(x.GetTimeout().AsDuration()),
		PermitWithoutStream: starlark.Bool(x.GetPermitWithoutStream()),
	}
}

func (x *ClientKeepaliveConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "time":
		x.Time = val.(time.Duration)
	case "timeout":
		x.Timeout = val.(time.Duration)
	case "permitWithoutStream", "permit_without_stream":
		x.PermitWithoutStream = val.(starlark.Bool)
	default:
		return nil
	}
	return nil
}

type ClientOAuthConfigurationStarlark struct {
	Credentials              starlark.Value
	GoogleDefaultCredentials starlarkutil.Empty
	ServiceAccountKey        starlark.String
	Scopes                   *starlark.List
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.ClientOAuthConfiguration", new(ClientOAuthConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ClientOAuthConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ClientOAuthConfigurationStarlark)(nil)
)

func (x *ClientOAuthConfigurationStarlark) String() string {
	if x == nil {
		return "ClientOAuthConfiguration{}"
	}
	return fmt.Sprintf("ClientOAuthConfiguration{"+
		"credentials= %s"+
		"googleDefaultCredentials= %s"+
		", serviceAccountKey= %s"+
		", scopes= %s"+
		"}",
		x.Credentials,
		x.GoogleDefaultCredentials,
		x.ServiceAccountKey,
		x.Scopes,
	)
}

func (x *ClientOAuthConfigurationStarlark) Type() string {
	return "buildbarn.configuration.grpc.ClientOAuthConfiguration"
}
func (x *ClientOAuthConfigurationStarlark) Freeze()              {}
func (x *ClientOAuthConfigurationStarlark) Truth() starlark.Bool { return true }
func (x *ClientOAuthConfigurationStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ClientOAuthConfigurationStarlark) AttrNames() []string {
	return []string{
		"credentials",
		"googleDefaultCredentials", "google_default_credentials",
		"serviceAccountKey", "service_account_key",
		"scopes",
	}
}

func (x *ClientOAuthConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "credentials":
		return x.Credentials, nil
	case "googleDefaultCredentials", "google_default_credentials":
		return x.GoogleDefaultCredentials, nil
	case "serviceAccountKey", "service_account_key":
		return x.ServiceAccountKey, nil
	case "scopes":
		return x.Scopes, nil
	default:
		return nil, nil
	}
}

func (x *ClientOAuthConfiguration) ToStarlark() *ClientOAuthConfigurationStarlark {
	if x == nil {
		return nil
	}

	l_Scopes := make([]starlark.Value, len(x.GetScopes()))
	for i, x := range x.GetScopes() {
		l_Scopes[i] = starlark.String(x)
	}

	var oneof_Credentials starlark.Value
	switch x.Credentials.(type) {
	case *ClientOAuthConfiguration_GoogleDefaultCredentials:
		oneof_Credentials = starlarkutil.ToEmpty(x.GetGoogleDefaultCredentials())
	case *ClientOAuthConfiguration_ServiceAccountKey:
		oneof_Credentials = starlark.String(x.GetServiceAccountKey())
	default:
		oneof_Credentials = starlark.None
	}

	return &ClientOAuthConfigurationStarlark{
		Credentials:              oneof_Credentials,
		GoogleDefaultCredentials: starlarkutil.ToEmpty(x.GetGoogleDefaultCredentials()),
		ServiceAccountKey:        starlark.String(x.GetServiceAccountKey()),
		Scopes:                   starlark.NewList(l_Scopes),
	}
}

func (x *ClientOAuthConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "credentials":
		x.Credentials = val.(starlarkutil.Empty)
	case "googleDefaultCredentials", "google_default_credentials":
		x.GoogleDefaultCredentials = val.(starlarkutil.Empty)
	case "serviceAccountKey", "service_account_key":
		x.ServiceAccountKey = val.(starlark.String)
	case "scopes":
		x.Scopes = val.(*starlark.List)
	default:
		return nil
	}
	return nil
}

type ServerConfigurationStarlark struct {
	ListenAddresses                 *starlark.List
	ListenPaths                     *starlark.List
	Tls                             *tls.ServerConfigurationStarlark
	AuthenticationPolicy            *AuthenticationPolicyStarlark
	MaximumReceivedMessageSizeBytes starlark.Int
	KeepaliveEnforcementPolicy      *ServerKeepaliveEnforcementPolicyStarlark
	HealthCheckService              starlark.String
	InitialWindowSizeBytes          starlark.Int
	InitialConnWindowSizeBytes      starlark.Int
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.ServerConfiguration", new(ServerConfigurationStarlark))
}

var (
	_ starlark.Value    = (*ServerConfigurationStarlark)(nil)
	_ starlark.HasAttrs = (*ServerConfigurationStarlark)(nil)
)

func (x *ServerConfigurationStarlark) String() string {
	if x == nil {
		return "ServerConfiguration{}"
	}
	return fmt.Sprintf("ServerConfiguration{"+
		"listenAddresses= %s"+
		", listenPaths= %s"+
		", tls= %s"+
		", authenticationPolicy= %s"+
		", maximumReceivedMessageSizeBytes= %s"+
		", keepaliveEnforcementPolicy= %s"+
		", healthCheckService= %s"+
		", initialWindowSizeBytes= %s"+
		", initialConnWindowSizeBytes= %s"+
		"}",
		x.ListenAddresses,
		x.ListenPaths,
		x.Tls,
		x.AuthenticationPolicy,
		x.MaximumReceivedMessageSizeBytes,
		x.KeepaliveEnforcementPolicy,
		x.HealthCheckService,
		x.InitialWindowSizeBytes,
		x.InitialConnWindowSizeBytes,
	)
}

func (x *ServerConfigurationStarlark) Type() string {
	return "buildbarn.configuration.grpc.ServerConfiguration"
}
func (x *ServerConfigurationStarlark) Freeze()               {}
func (x *ServerConfigurationStarlark) Truth() starlark.Bool  { return true }
func (x *ServerConfigurationStarlark) Hash() (uint32, error) { return 0, fmt.Errorf("un-hashable") }
func (x *ServerConfigurationStarlark) AttrNames() []string {
	return []string{
		"listenAddresses", "listen_addresses",
		"listenPaths", "listen_paths",
		"tls",
		"authenticationPolicy", "authentication_policy",
		"maximumReceivedMessageSizeBytes", "maximum_received_message_size_bytes",
		"keepaliveEnforcementPolicy", "keepalive_enforcement_policy",
		"healthCheckService", "health_check_service",
		"initialWindowSizeBytes", "initial_window_size_bytes",
		"initialConnWindowSizeBytes", "initial_conn_window_size_bytes",
	}
}

func (x *ServerConfigurationStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "listenAddresses", "listen_addresses":
		return x.ListenAddresses, nil
	case "listenPaths", "listen_paths":
		return x.ListenPaths, nil
	case "tls":
		return x.Tls, nil
	case "authenticationPolicy", "authentication_policy":
		return x.AuthenticationPolicy, nil
	case "maximumReceivedMessageSizeBytes", "maximum_received_message_size_bytes":
		return x.MaximumReceivedMessageSizeBytes, nil
	case "keepaliveEnforcementPolicy", "keepalive_enforcement_policy":
		return x.KeepaliveEnforcementPolicy, nil
	case "healthCheckService", "health_check_service":
		return x.HealthCheckService, nil
	case "initialWindowSizeBytes", "initial_window_size_bytes":
		return x.InitialWindowSizeBytes, nil
	case "initialConnWindowSizeBytes", "initial_conn_window_size_bytes":
		return x.InitialConnWindowSizeBytes, nil
	default:
		return nil, nil
	}
}

func (x *ServerConfiguration) ToStarlark() *ServerConfigurationStarlark {
	if x == nil {
		return nil
	}

	l_ListenAddresses := make([]starlark.Value, len(x.GetListenAddresses()))
	for i, x := range x.GetListenAddresses() {
		l_ListenAddresses[i] = starlark.String(x)
	}

	l_ListenPaths := make([]starlark.Value, len(x.GetListenPaths()))
	for i, x := range x.GetListenPaths() {
		l_ListenPaths[i] = starlark.String(x)
	}

	return &ServerConfigurationStarlark{
		ListenAddresses:                 starlark.NewList(l_ListenAddresses),
		ListenPaths:                     starlark.NewList(l_ListenPaths),
		Tls:                             x.GetTls().ToStarlark(),
		AuthenticationPolicy:            x.GetAuthenticationPolicy().ToStarlark(),
		MaximumReceivedMessageSizeBytes: starlark.MakeInt64(int64(x.GetMaximumReceivedMessageSizeBytes())),
		KeepaliveEnforcementPolicy:      x.GetKeepaliveEnforcementPolicy().ToStarlark(),
		HealthCheckService:              starlark.String(x.GetHealthCheckService()),
		InitialWindowSizeBytes:          starlark.MakeInt64(int64(x.GetInitialWindowSizeBytes())),
		InitialConnWindowSizeBytes:      starlark.MakeInt64(int64(x.GetInitialConnWindowSizeBytes())),
	}
}

func (x *ServerConfigurationStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "listenAddresses", "listen_addresses":
		x.ListenAddresses = val.(*starlark.List)
	case "listenPaths", "listen_paths":
		x.ListenPaths = val.(*starlark.List)
	case "tls":
		x.Tls = val.(*tls.ServerConfigurationStarlark)
	case "authenticationPolicy", "authentication_policy":
		x.AuthenticationPolicy = val.(*AuthenticationPolicyStarlark)
	case "maximumReceivedMessageSizeBytes", "maximum_received_message_size_bytes":
		x.MaximumReceivedMessageSizeBytes = val.(starlark.Int)
	case "keepaliveEnforcementPolicy", "keepalive_enforcement_policy":
		x.KeepaliveEnforcementPolicy = val.(*ServerKeepaliveEnforcementPolicyStarlark)
	case "healthCheckService", "health_check_service":
		x.HealthCheckService = val.(starlark.String)
	case "initialWindowSizeBytes", "initial_window_size_bytes":
		x.InitialWindowSizeBytes = val.(starlark.Int)
	case "initialConnWindowSizeBytes", "initial_conn_window_size_bytes":
		x.InitialConnWindowSizeBytes = val.(starlark.Int)
	default:
		return nil
	}
	return nil
}

type ServerKeepaliveEnforcementPolicyStarlark struct {
	MinTime             time.Duration
	PermitWithoutStream starlark.Bool
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.ServerKeepaliveEnforcementPolicy", new(ServerKeepaliveEnforcementPolicyStarlark))
}

var (
	_ starlark.Value    = (*ServerKeepaliveEnforcementPolicyStarlark)(nil)
	_ starlark.HasAttrs = (*ServerKeepaliveEnforcementPolicyStarlark)(nil)
)

func (x *ServerKeepaliveEnforcementPolicyStarlark) String() string {
	if x == nil {
		return "ServerKeepaliveEnforcementPolicy{}"
	}
	return fmt.Sprintf("ServerKeepaliveEnforcementPolicy{"+
		"minTime= %s"+
		", permitWithoutStream= %s"+
		"}",
		x.MinTime,
		x.PermitWithoutStream,
	)
}

func (x *ServerKeepaliveEnforcementPolicyStarlark) Type() string {
	return "buildbarn.configuration.grpc.ServerKeepaliveEnforcementPolicy"
}
func (x *ServerKeepaliveEnforcementPolicyStarlark) Freeze()              {}
func (x *ServerKeepaliveEnforcementPolicyStarlark) Truth() starlark.Bool { return true }
func (x *ServerKeepaliveEnforcementPolicyStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ServerKeepaliveEnforcementPolicyStarlark) AttrNames() []string {
	return []string{
		"minTime", "min_time",
		"permitWithoutStream", "permit_without_stream",
	}
}

func (x *ServerKeepaliveEnforcementPolicyStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "minTime", "min_time":
		return x.MinTime, nil
	case "permitWithoutStream", "permit_without_stream":
		return x.PermitWithoutStream, nil
	default:
		return nil, nil
	}
}

func (x *ServerKeepaliveEnforcementPolicy) ToStarlark() *ServerKeepaliveEnforcementPolicyStarlark {
	if x == nil {
		return nil
	}

	return &ServerKeepaliveEnforcementPolicyStarlark{
		MinTime:             time.Duration(x.GetMinTime().AsDuration()),
		PermitWithoutStream: starlark.Bool(x.GetPermitWithoutStream()),
	}
}

func (x *ServerKeepaliveEnforcementPolicyStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "minTime", "min_time":
		x.MinTime = val.(time.Duration)
	case "permitWithoutStream", "permit_without_stream":
		x.PermitWithoutStream = val.(starlark.Bool)
	default:
		return nil
	}
	return nil
}

type AuthenticationPolicyStarlark struct {
	Policy               starlark.Value
	Allow                starlarkutil.Empty
	Any                  *AnyAuthenticationPolicyStarlark
	Deny                 starlark.String
	TlsClientCertificate *TLSClientCertificateAuthenticationPolicyStarlark
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.AuthenticationPolicy", new(AuthenticationPolicyStarlark))
}

var (
	_ starlark.Value    = (*AuthenticationPolicyStarlark)(nil)
	_ starlark.HasAttrs = (*AuthenticationPolicyStarlark)(nil)
)

func (x *AuthenticationPolicyStarlark) String() string {
	if x == nil {
		return "AuthenticationPolicy{}"
	}
	return fmt.Sprintf("AuthenticationPolicy{"+
		"policy= %s"+
		"allow= %s"+
		", any= %s"+
		", deny= %s"+
		", tlsClientCertificate= %s"+
		"}",
		x.Policy,
		x.Allow,
		x.Any,
		x.Deny,
		x.TlsClientCertificate,
	)
}

func (x *AuthenticationPolicyStarlark) Type() string {
	return "buildbarn.configuration.grpc.AuthenticationPolicy"
}
func (x *AuthenticationPolicyStarlark) Freeze()               {}
func (x *AuthenticationPolicyStarlark) Truth() starlark.Bool  { return true }
func (x *AuthenticationPolicyStarlark) Hash() (uint32, error) { return 0, fmt.Errorf("un-hashable") }
func (x *AuthenticationPolicyStarlark) AttrNames() []string {
	return []string{
		"policy",
		"allow",
		"any",
		"deny",
		"tlsClientCertificate", "tls_client_certificate",
	}
}

func (x *AuthenticationPolicyStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "policy":
		return x.Policy, nil
	case "allow":
		return x.Allow, nil
	case "any":
		return x.Any, nil
	case "deny":
		return x.Deny, nil
	case "tlsClientCertificate", "tls_client_certificate":
		return x.TlsClientCertificate, nil
	default:
		return nil, nil
	}
}

func (x *AuthenticationPolicy) ToStarlark() *AuthenticationPolicyStarlark {
	if x == nil {
		return nil
	}

	var oneof_Policy starlark.Value
	switch x.Policy.(type) {
	case *AuthenticationPolicy_Allow:
		oneof_Policy = starlarkutil.ToEmpty(x.GetAllow())
	case *AuthenticationPolicy_Any:
		oneof_Policy = x.GetAny().ToStarlark()
	case *AuthenticationPolicy_Deny:
		oneof_Policy = starlark.String(x.GetDeny())
	case *AuthenticationPolicy_TlsClientCertificate:
		oneof_Policy = x.GetTlsClientCertificate().ToStarlark()
	default:
		oneof_Policy = starlark.None
	}

	return &AuthenticationPolicyStarlark{
		Policy:               oneof_Policy,
		Allow:                starlarkutil.ToEmpty(x.GetAllow()),
		Any:                  x.GetAny().ToStarlark(),
		Deny:                 starlark.String(x.GetDeny()),
		TlsClientCertificate: x.GetTlsClientCertificate().ToStarlark(),
	}
}

func (x *AuthenticationPolicyStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "policy":
		x.Policy = val.(starlarkutil.Empty)
	case "allow":
		x.Allow = val.(starlarkutil.Empty)
	case "any":
		x.Any = val.(*AnyAuthenticationPolicyStarlark)
	case "deny":
		x.Deny = val.(starlark.String)
	case "tlsClientCertificate", "tls_client_certificate":
		x.TlsClientCertificate = val.(*TLSClientCertificateAuthenticationPolicyStarlark)
	default:
		return nil
	}
	return nil
}

type AnyAuthenticationPolicyStarlark struct {
	Policies *starlark.List
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.AnyAuthenticationPolicy", new(AnyAuthenticationPolicyStarlark))
}

var (
	_ starlark.Value    = (*AnyAuthenticationPolicyStarlark)(nil)
	_ starlark.HasAttrs = (*AnyAuthenticationPolicyStarlark)(nil)
)

func (x *AnyAuthenticationPolicyStarlark) String() string {
	if x == nil {
		return "AnyAuthenticationPolicy{}"
	}
	return fmt.Sprintf("AnyAuthenticationPolicy{"+
		"policies= %s"+
		"}",
		x.Policies,
	)
}

func (x *AnyAuthenticationPolicyStarlark) Type() string {
	return "buildbarn.configuration.grpc.AnyAuthenticationPolicy"
}
func (x *AnyAuthenticationPolicyStarlark) Freeze()               {}
func (x *AnyAuthenticationPolicyStarlark) Truth() starlark.Bool  { return true }
func (x *AnyAuthenticationPolicyStarlark) Hash() (uint32, error) { return 0, fmt.Errorf("un-hashable") }
func (x *AnyAuthenticationPolicyStarlark) AttrNames() []string {
	return []string{
		"policies",
	}
}

func (x *AnyAuthenticationPolicyStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "policies":
		return x.Policies, nil
	default:
		return nil, nil
	}
}

func (x *AnyAuthenticationPolicy) ToStarlark() *AnyAuthenticationPolicyStarlark {
	if x == nil {
		return nil
	}

	l_Policies := make([]starlark.Value, len(x.GetPolicies()))
	for i, x := range x.GetPolicies() {
		l_Policies[i] = x.ToStarlark()
	}

	return &AnyAuthenticationPolicyStarlark{
		Policies: starlark.NewList(l_Policies),
	}
}

func (x *AnyAuthenticationPolicyStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "policies":
		x.Policies = val.(*starlark.List)
	default:
		return nil
	}
	return nil
}

type TLSClientCertificateAuthenticationPolicyStarlark struct {
	ClientCertificateAuthorities starlark.String
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.TLSClientCertificateAuthenticationPolicy", new(TLSClientCertificateAuthenticationPolicyStarlark))
}

var (
	_ starlark.Value    = (*TLSClientCertificateAuthenticationPolicyStarlark)(nil)
	_ starlark.HasAttrs = (*TLSClientCertificateAuthenticationPolicyStarlark)(nil)
)

func (x *TLSClientCertificateAuthenticationPolicyStarlark) String() string {
	if x == nil {
		return "TLSClientCertificateAuthenticationPolicy{}"
	}
	return fmt.Sprintf("TLSClientCertificateAuthenticationPolicy{"+
		"clientCertificateAuthorities= %s"+
		"}",
		x.ClientCertificateAuthorities,
	)
}

func (x *TLSClientCertificateAuthenticationPolicyStarlark) Type() string {
	return "buildbarn.configuration.grpc.TLSClientCertificateAuthenticationPolicy"
}
func (x *TLSClientCertificateAuthenticationPolicyStarlark) Freeze()              {}
func (x *TLSClientCertificateAuthenticationPolicyStarlark) Truth() starlark.Bool { return true }
func (x *TLSClientCertificateAuthenticationPolicyStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *TLSClientCertificateAuthenticationPolicyStarlark) AttrNames() []string {
	return []string{
		"clientCertificateAuthorities", "client_certificate_authorities",
	}
}

func (x *TLSClientCertificateAuthenticationPolicyStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "clientCertificateAuthorities", "client_certificate_authorities":
		return x.ClientCertificateAuthorities, nil
	default:
		return nil, nil
	}
}

func (x *TLSClientCertificateAuthenticationPolicy) ToStarlark() *TLSClientCertificateAuthenticationPolicyStarlark {
	if x == nil {
		return nil
	}

	return &TLSClientCertificateAuthenticationPolicyStarlark{
		ClientCertificateAuthorities: starlark.String(x.GetClientCertificateAuthorities()),
	}
}

func (x *TLSClientCertificateAuthenticationPolicyStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "clientCertificateAuthorities", "client_certificate_authorities":
		x.ClientCertificateAuthorities = val.(starlark.String)
	default:
		return nil
	}
	return nil
}

type ClientConfiguration_HeaderValuesStarlark struct {
	Header starlark.String
	Values *starlark.List
}

func init() {
	configuration.Register("buildbarn.configuration.grpc.ClientConfiguration.HeaderValues", new(ClientConfiguration_HeaderValuesStarlark))
}

var (
	_ starlark.Value    = (*ClientConfiguration_HeaderValuesStarlark)(nil)
	_ starlark.HasAttrs = (*ClientConfiguration_HeaderValuesStarlark)(nil)
)

func (x *ClientConfiguration_HeaderValuesStarlark) String() string {
	if x == nil {
		return "HeaderValues{}"
	}
	return fmt.Sprintf("HeaderValues{"+
		"header= %s"+
		", values= %s"+
		"}",
		x.Header,
		x.Values,
	)
}

func (x *ClientConfiguration_HeaderValuesStarlark) Type() string {
	return "buildbarn.configuration.grpc.ClientConfiguration.HeaderValues"
}
func (x *ClientConfiguration_HeaderValuesStarlark) Freeze()              {}
func (x *ClientConfiguration_HeaderValuesStarlark) Truth() starlark.Bool { return true }
func (x *ClientConfiguration_HeaderValuesStarlark) Hash() (uint32, error) {
	return 0, fmt.Errorf("un-hashable")
}

func (x *ClientConfiguration_HeaderValuesStarlark) AttrNames() []string {
	return []string{
		"header",
		"values",
	}
}

func (x *ClientConfiguration_HeaderValuesStarlark) Attr(name string) (starlark.Value, error) {
	if x == nil {
		return nil, nil
	}
	switch name {
	case "header":
		return x.Header, nil
	case "values":
		return x.Values, nil
	default:
		return nil, nil
	}
}

func (x *ClientConfiguration_HeaderValues) ToStarlark() *ClientConfiguration_HeaderValuesStarlark {
	if x == nil {
		return nil
	}

	l_Values := make([]starlark.Value, len(x.GetValues()))
	for i, x := range x.GetValues() {
		l_Values[i] = starlark.String(x)
	}

	return &ClientConfiguration_HeaderValuesStarlark{
		Header: starlark.String(x.GetHeader()),
		Values: starlark.NewList(l_Values),
	}
}

func (x *ClientConfiguration_HeaderValuesStarlark) SetField(name string, val starlark.Value) error {
	switch name {
	case "header":
		x.Header = val.(starlark.String)
	case "values":
		x.Values = val.(*starlark.List)
	default:
		return nil
	}
	return nil
}
